<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ—¾ ì¼ë³¸ì–´ ë‹¨ì–´ ê³µë¶€</title>
    
    <!-- PWA ë©”íƒ€ íƒœê·¸ë“¤ -->
    <meta name="description" content="ì¼ë³¸ì–´ ë‹¨ì–´ì™€ íˆë¼ê°€ë‚˜ë¥¼ ì‰½ê²Œ ê³µë¶€í•  ìˆ˜ ìˆëŠ” ì•± ^_^">
    <meta name="theme-color" content="#667eea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ì¼ë³¸ì–´ê³µë¶€">
    <meta name="msapplication-TileColor" content="#667eea">
    <link rel="manifest" href="./manifest.json">
    
    <!-- ì•„ì´ì½˜ë“¤ -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjNjY3ZWVhIiByeD0iMjQiLz4KPHA+8J+Yr/CfmLDwn5iy8J+Ys+CfmLfwn5i78J+YvvCfmL88L3A+DQo8L3N2Zz4=">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjNjY3ZWVhIiByeD0iMjQiLz4KPHA+8J+Yr/CfmLDwn5iy8J+Ys+CfmLfwn5i78J+YvvCfmL88L3A+DQo8L3N2Zz4=">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav {
            display: flex;
            gap: 1rem;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .nav-btn.active {
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .main {
            flex: 1;
            padding: 2rem;
            display: flex;
            justify-content: center;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }

        .quiz-word {
            text-align: center;
            margin: 2rem 0;
        }

        .kanji {
            font-size: 4rem;
            color: #9b59b6;
            margin-bottom: 1rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .hiragana {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 2rem;
            font-weight: 600;
        }

        .input-group {
            margin: 1.5rem 0;
        }

        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .input-field {
            width: 100%;
            padding: 1rem;
            border: 2px solid #e1e8ed;
            border-radius: 12px;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            background: white;
        }

        .input-field:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .score {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #27ae60;
            margin-bottom: 2rem;
        }

        .result {
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 12px;
            animation: fadeIn 0.5s ease;
        }

        .result.correct {
            background: rgba(46, 204, 113, 0.1);
            color: #27ae60;
        }

        .result.incorrect {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }

        .result.partial {
            background: rgba(243, 156, 18, 0.1);
            color: #d68910;
            border-left: 4px solid #f39c12;
        }

        .word-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e1e8ed;
            border-radius: 12px;
            padding: 1rem;
        }

        .word-item {
            padding: 1rem;
            border-bottom: 1px solid #e1e8ed;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .word-item:hover {
            background: rgba(52, 152, 219, 0.05);
        }

        .word-item:last-child {
            border-bottom: none;
        }

        .status-indicator {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            margin: 1rem 0;
        }

        .status-success {
            background: rgba(46, 204, 113, 0.1);
            color: #27ae60;
        }

        .status-error {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }

        .hangul-converter {
            background: rgba(52, 152, 219, 0.05);
            border: 2px dashed #3498db;
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .btn-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin: 2rem 0;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-weight: 500;
            font-size: 1rem;
            min-width: 300px;
            max-width: 400px;
            animation: slideInFromRight 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .notification.success {
            background: rgba(46, 204, 113, 0.9);
            color: white;
            border-color: rgba(46, 204, 113, 0.3);
        }

        .notification.error {
            background: rgba(231, 76, 60, 0.9);
            color: white;
            border-color: rgba(231, 76, 60, 0.3);
        }

        .notification.warning {
            background: rgba(241, 196, 15, 0.9);
            color: white;
            border-color: rgba(241, 196, 15, 0.3);
        }

        .notification.info {
            background: rgba(52, 152, 219, 0.9);
            color: white;
            border-color: rgba(52, 152, 219, 0.3);
        }

        @keyframes slideInFromRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            opacity: 0.8;
            margin-left: auto;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            opacity: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease;
        }

        .slide-in {
            animation: slideIn 0.3s ease;
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .header > div:nth-child(2) {
                flex-wrap: wrap;
                justify-content: center;
            }

            .header select {
                min-width: 200px;
            }
            
            .main {
                padding: 1rem;
            }
            
            .kanji {
                font-size: 3rem;
            }
            
            .hiragana {
                font-size: 2rem;
            }
            
            .btn-group {
                flex-direction: column;
            }
        }

        /* ì»¤ìŠ¤í…€ íŒì—… ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .custom-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .custom-popup.show {
            opacity: 1;
            visibility: visible;
        }
        
        .popup-content {
            background: white;
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            transform: scale(0.7);
            transition: transform 0.3s ease;
        }
        
        .custom-popup.show .popup-content {
            transform: scale(1);
        }
        
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #f1f2f6;
        }
        
        .popup-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 0;
        }
        
        .popup-close {
            background: none;
            border: none;
            font-size: 1.8rem;
            cursor: pointer;
            color: #7f8c8d;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .popup-close:hover {
            background-color: #f1f2f6;
            color: #e74c3c;
        }
        
        .popup-body {
            margin-bottom: 2rem;
        }
        
        .popup-message {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 1.5rem;
        }
        
        .popup-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        
        .popup-btn {
            padding: 0.8rem 1.8rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }
        
        .popup-btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }
        
        .popup-btn-primary:hover {
            background: linear-gradient(45deg, #2980b9, #1abc9c);
            transform: translateY(-2px);
        }
        
        .popup-btn-secondary {
            background: #ecf0f1;
            color: #34495e;
            border: 2px solid #bdc3c7;
        }
        
        .popup-btn-secondary:hover {
            background: #d5dbdb;
            border-color: #95a5a6;
        }
        
        .popup-btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }
        
        .popup-btn-success:hover {
            background: linear-gradient(45deg, #229954, #27ae60);
            transform: translateY(-2px);
        }
        
        .popup-btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .popup-btn-danger:hover {
            background: linear-gradient(45deg, #c0392b, #a93226);
            transform: translateY(-2px);
        }

        /* íˆë¼ê°€ë‚˜ ê°€ë¦¼ íš¨ê³¼ */
        .hiragana-container {
            position: relative;
            display: inline-block;
            margin: 2rem 0;
        }

        .hiragana-hidden {
            filter: blur(20px);
            color: transparent;
            text-shadow: none;
            user-select: none;
            pointer-events: none;
        }

        .hiragana-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
            animation: pulse 2s infinite;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            white-space: nowrap;
            z-index: 10;
        }

        .hiragana-toggle-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .hiragana-toggle-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: scale(1.1);
        }

        .quiz-word {
            position: relative;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        /* í€´ì¦ˆ í™”ë©´ ì¦ê²¨ì°¾ê¸° ë²„íŠ¼ ìµœì í™” */
        .quiz-favorite-btn {
            position: absolute;
            top: -10px;
            left: -10px;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 5;
            color: white;
            backdrop-filter: blur(10px);
        }

        .quiz-favorite-btn:hover {
            transform: scale(1.15) rotate(5deg);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .quiz-favorite-btn:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        /* ë³„ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .quiz-favorite-btn.favorited {
            animation: starPulse 0.6s ease-in-out;
        }
        
        /* ëª¨ë°”ì¼ ìµœì í™” */
        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
                margin: 0;
            }
            
            .card {
                padding: 1rem;
                margin-bottom: 1rem;
                border-radius: 12px;
            }
            
            .quiz-word .kanji {
                font-size: 2.5rem !important;
            }
            
            .quiz-word .hiragana {
                font-size: 1.8rem !important;
            }
            
            .btn-group {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .btn {
                width: 100%;
                min-width: auto !important;
                padding: 1rem;
                font-size: 1rem;
            }
            
            .input-field {
                font-size: 1rem;
                padding: 1rem;
            }
            
            .nav-btn {
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
            }
            
            /* 2ë‹¨ê³„ í€´ì¦ˆ ì„ íƒ ë²„íŠ¼ë“¤ */
            div[style*="display: flex"][style*="gap: 1rem"] {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            
            /* ëª¨ë°”ì¼ì—ì„œ ë³€í™˜ ì•ˆë‚´ í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì • */
            div[style*="background: rgba(46, 204, 113, 0.1)"] {
                font-size: 0.8rem !important;
            }
        }
        
        /* ì•„ì£¼ ì‘ì€ í™”ë©´ (320px ì´í•˜) */
        @media (max-width: 320px) {
            .card {
                padding: 0.8rem;
            }
            
            .quiz-word .kanji {
                font-size: 2rem !important;
            }
            
            .quiz-word .hiragana {
                font-size: 1.5rem !important;
            }
            
            .btn {
                padding: 0.8rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- ì»¤ìŠ¤í…€ íŒì—… ëª¨ë‹¬ -->
    <div id="customPopup" class="custom-popup">
        <div class="popup-content">
            <div class="popup-header">
                <h3 id="popupTitle" class="popup-title">ì•Œë¦¼</h3>
                <button class="popup-close" onclick="closeCustomPopup()">Ã—</button>
            </div>
            <div class="popup-body">
                <div id="popupMessage" class="popup-message"></div>
            </div>
            <div class="popup-buttons">
                <button id="popupOkBtn" class="popup-btn popup-btn-primary" onclick="closeCustomPopup()">í™•ì¸</button>
                <button id="popupCancelBtn" class="popup-btn popup-btn-secondary" onclick="closeCustomPopup()" style="display: none;">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>


    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // ì»¤ìŠ¤í…€ íŒì—… ê´€ë¦¬ í•¨ìˆ˜ë“¤
        function showCustomPopup(message, title = 'ì•Œë¦¼', type = 'info', showCancel = false) {
            const popup = document.getElementById('customPopup');
            const titleElement = document.getElementById('popupTitle');
            const messageElement = document.getElementById('popupMessage');
            const okBtn = document.getElementById('popupOkBtn');
            const cancelBtn = document.getElementById('popupCancelBtn');
            
            // ë‚´ìš© ì„¤ì •
            titleElement.textContent = title;
            messageElement.textContent = message;
            
            // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì„¤ì •
            okBtn.className = 'popup-btn ';
            switch(type) {
                case 'success':
                    okBtn.className += 'popup-btn-success';
                    break;
                case 'error':
                case 'danger':
                    okBtn.className += 'popup-btn-danger';
                    break;
                case 'warning':
                    okBtn.className += 'popup-btn-primary';
                    break;
                default:
                    okBtn.className += 'popup-btn-primary';
            }
            
            // ì·¨ì†Œ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
            if (showCancel) {
                cancelBtn.style.display = 'inline-block';
            } else {
                cancelBtn.style.display = 'none';
            }
            
            // íŒì—… í‘œì‹œ
            popup.classList.add('show');
            
            return new Promise((resolve) => {
                // í™•ì¸ ë²„íŠ¼ í´ë¦­ ì‹œ
                okBtn.onclick = () => {
                    closeCustomPopup();
                    resolve(true);
                };
                
                // ì·¨ì†Œ ë²„íŠ¼ í´ë¦­ ì‹œ
                if (showCancel) {
                    cancelBtn.onclick = () => {
                        closeCustomPopup();
                        resolve(false);
                    };
                }
            });
        }
        
        function closeCustomPopup() {
            const popup = document.getElementById('customPopup');
            popup.classList.remove('show');
        }
        
        // ESC í‚¤ë¡œ íŒì—… ë‹«ê¸°
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeCustomPopup();
            }
        });
        
        // ë°°ê²½ í´ë¦­ìœ¼ë¡œ íŒì—… ë‹«ê¸°
        document.getElementById('customPopup').addEventListener('click', function(event) {
            if (event.target === this) {
                closeCustomPopup();
            }
        });

        // í™•ì¥ëœ í•œì ì‚¬ì „ì— ãŠã¨ ì¶”ê°€
        const kanjiDict = {
            "ãŒã£ã“ã†": "å­¦æ ¡", "ã›ã‚“ã›ã„": "å…ˆç”Ÿ", "ãŒãã›ã„": "å­¦ç”Ÿ",
            "ãŸã¹ã‚‚ã®": "é£Ÿã¹ç‰©", "ã¿ãš": "æ°´", "ã˜ã‹ã‚“": "æ™‚é–“",
            "ã¨ã‚‚ã ã¡": "å‹é”", "ã‹ãã": "å®¶æ—", "ã—ã”ã¨": "ä»•äº‹",
            "ã„ãˆ": "å®¶", "ã‚ãŸã¾": "é ­", "ã“ã“ã‚": "å¿ƒ",
            "ã¦ãŒã¿": "æ‰‹ç´™", "ã§ã‚“ã‚": "é›»è©±", "ãã‚‹ã¾": "è»Š",
            "ãˆã": "é§…", "ã³ã‚‡ã†ã„ã‚“": "ç—…é™¢", "ãã‚“ã“ã†": "éŠ€è¡Œ",
            "ã“ã†ãˆã‚“": "å…¬åœ’", "ã¨ã—ã‚‡ã‹ã‚“": "å›³æ›¸é¤¨", "ã‹ã„ã—ã‚ƒ": "ä¼šç¤¾",
            "ã¯ãªã—": "è©±", "ã¹ã‚“ãã‚‡ã†": "å‹‰å¼·", "ã—ã‚…ãã ã„": "å®¿é¡Œ",
            "ã§ã‚“ã—ã‚ƒ": "é›»è»Š", "ã˜ã¦ã‚“ã—ã‚ƒ": "è‡ªè»¢è»Š", "ã²ã“ã†ã": "é£›è¡Œæ©Ÿ",
            
            // ì¶”ê°€ëœ ê¸°ë³¸ í•œìë“¤
            "ãŠã¨": "éŸ³", "ã“ãˆ": "å£°", "ã‚": "ç›®", "ã¦": "æ‰‹", 
            "ã‚ã—": "è¶³", "ã‚ãŸã¾": "é ­", "ã‹ã‚‰ã ": "ä½“", "ã²ã¨": "äºº",
            "ã„ã¡": "ä¸€", "ã«": "äºŒ", "ã•ã‚“": "ä¸‰", "ã‚ˆã‚“": "å››", "ã”": "äº”",
            "ã‚ã": "å…­", "ãªãª": "ä¸ƒ", "ã¯ã¡": "å…«", "ãã‚…ã†": "ä¹", "ã˜ã‚…ã†": "å",
            "ã²": "æ—¥", "ã¤ã": "æœˆ", "ã‹": "ç«", "ã™ã„": "æ°´", "ã‚‚ã": "æœ¨", 
            "ãã‚“": "é‡‘", "ã©": "åœŸ", "ã«ã¡": "æ—¥", "ã’ã¤": "æœˆ", "ã‹": "ç«",
            "ã‚ã‹": "èµ¤", "ã‚ãŠ": "é’", "ã—ã‚": "ç™½", "ãã‚": "é»’", "ãã„ã‚": "é»„"
        };

        // í™•ì¥ëœ í•œê¸€-íˆë¼ê°€ë‚˜ ë³€í™˜ (ë³µí•©ìŒ, ìš”ìŒ í¬í•¨)
        const hangulToHiragana = {
            // ê¸°ë³¸ ëª¨ìŒ (ì¤‘ìš”!)
            'ã…': 'ã‚', 'ã…£': 'ã„', 'ã…œ': 'ã†', 'ã…“': 'ãˆ', 'ã…—': 'ãŠ',
            'ã…‘': 'ã‚„', 'ã…•': 'ã‚ˆ', 'ã… ': 'ã‚†', 'ã…›': 'ã‚ˆ', 'ã…˜': 'ã‚', 'ã…™': 'ã‚ã„', 'ã…š': 'ã†ã‡',
            'ã…': 'ã†ã‰', 'ã…': 'ã†ã‡', 'ã…Ÿ': 'ã†ã„', 'ã…¢': 'ã†ã„', 'ã…”': 'ãˆ', 'ã…': 'ãˆ',
            
            // ê¸°ë³¸ ììŒ (ë‹¨ë…)
            'ã„±': 'ãŒ', 'ã„´': 'ã‚“', 'ã„·': 'ã ', 'ã„¹': 'ã‚‰', 'ã…': 'ã¾', 'ã…‚': 'ã°', 
            'ã……': 'ã•', 'ã…‡': '', 'ã…ˆ': 'ã˜', 'ã…Š': 'ã¡', 'ã…‹': 'ã‹', 'ã…Œ': 'ãŸ', 
            'ã…': 'ã±', 'ã…': 'ã¯',
            
            // ì†Œì¿ ì˜¨(ì´‰ìŒ) ã…… â†’ ã£ ì²˜ë¦¬
            'ã……ã……': 'ã£', 'ã£': 'ã£',
            
            // ì™€í–‰ ì¶”ê°€ (ì¤‘ìš”!)
            'ì™€': 'ã‚', 'ì™œ': 'ã‚ã„', 'ì™¸': 'ã†ã‡', 'ì›¨': 'ã†ã‡', 'ìœ„': 'ã†ã„', 'ì˜': 'ã†ã„',
            
            // ê¸°ë³¸ ììŒ+ëª¨ìŒ
            'ê°€': 'ãŒ', 'ê°¸': 'ãã‚ƒ', 'ê±°': 'ã’', 'ê²¨': 'ãã‡', 'ê³ ': 'ã”', 'êµ': 'ãã‚‡', 'êµ¬': 'ã', 'ê·œ': 'ãã‚…', 'ê·¸': 'ã', 'ê¸°': 'ã', 'ê°œ': 'ãŒã„', 'ê²Œ': 'ã’',
            'ë‚˜': 'ãª', 'ëƒ': 'ã«ã‚ƒ', 'ë„ˆ': 'ã­', 'ë…€': 'ã«ã‡', 'ë…¸': 'ã®', 'ë‡¨': 'ã«ã‚‡', 'ëˆ„': 'ã¬', 'ë‰´': 'ã«ã‚…', 'ëŠ': 'ã¬', 'ë‹ˆ': 'ã«', 'ë‚´': 'ãªã„', 'ë„¤': 'ã­',
            'ë‹¤': 'ã ', 'ëŒœ': 'ã¢ã‚ƒ', 'ë”': 'ã§', 'ëŒ': 'ã¢ã‡', 'ë„': 'ã©', 'ë´': 'ã¢ã‚‡', 'ë‘': 'ã¥', 'ë“€': 'ã¢ã‚…', 'ë“œ': 'ã¥', 'ë””': 'ã¢', 'ëŒ€': 'ã ã„', 'ë°': 'ã§',
            'ë¼': 'ã‚‰', 'ë´': 'ã‚Šã‚ƒ', 'ëŸ¬': 'ã‚Œ', 'ë ¤': 'ã‚Šã‡', 'ë¡œ': 'ã‚', 'ë£Œ': 'ã‚Šã‚‡', 'ë£¨': 'ã‚‹', 'ë¥˜': 'ã‚Šã‚…', 'ë¥´': 'ã‚‹', 'ë¦¬': 'ã‚Š', 'ë˜': 'ã‚‰ã„', 'ë ˆ': 'ã‚Œ',
            'ë§ˆ': 'ã¾', 'ë¨€': 'ã¿ã‚ƒ', 'ë¨¸': 'ã‚', 'ë©°': 'ã¿ã‡', 'ëª¨': 'ã‚‚', 'ë¬˜': 'ã¿ã‚‡', 'ë¬´': 'ã‚€', 'ë®¤': 'ã¿ã‚…', 'ë¯€': 'ã‚€', 'ë¯¸': 'ã¿', 'ë§¤': 'ã¾ã„', 'ë©”': 'ã‚',
            'ë°”': 'ã°', 'ë±Œ': 'ã³ã‚ƒ', 'ë²„': 'ã¹', 'ë²¼': 'ã³ã‡', 'ë³´': 'ã¼', 'ëµ¤': 'ã³ã‚‡', 'ë¶€': 'ã¶', 'ë·°': 'ã³ã‚…', 'ë¸Œ': 'ã¶', 'ë¹„': 'ã³', 'ë°°': 'ã°ã„', 'ë² ': 'ã¹',
            'ì‚¬': 'ã•', 'ìƒ¤': 'ã—ã‚ƒ', 'ì„œ': 'ã›', 'ì…”': 'ã—ã‡', 'ì†Œ': 'ã', 'ì‡¼': 'ã—ã‚‡', 'ìˆ˜': 'ã™', 'ìŠˆ': 'ã—ã‚…', 'ìŠ¤': 'ã™', 'ì‹œ': 'ã—', 'ìƒˆ': 'ã•ã„', 'ì„¸': 'ã›',
            'ì•„': 'ã‚', 'ì•¼': 'ã‚„', 'ì–´': 'ãˆ', 'ì—¬': 'ã„ã‡', 'ì˜¤': 'ãŠ', 'ìš”': 'ã‚ˆ', 'ìš°': 'ã†', 'ìœ ': 'ã‚†', 'ìœ¼': 'ã†', 'ì´': 'ã„', 'ì• ': 'ã‚ã„', 'ì—': 'ãˆ',
            'ì': 'ã–', 'ìŸˆ': 'ã˜ã‚ƒ', 'ì €': 'ãœ', 'ì ¸': 'ã˜ã‡', 'ì¡°': 'ã', 'ì£ ': 'ã˜ã‚‡', 'ì£¼': 'ãš', 'ì¥¬': 'ã˜ã‚…', 'ì¦ˆ': 'ãš', 'ì§€': 'ã˜', 'ì¬': 'ã–ã„', 'ì œ': 'ãœ',
            'ì°¨': 'ã¡ã‚ƒ', 'ì± ': 'ã¡ã‚ƒ', 'ì²˜': 'ã¡ã‡', 'ì³': 'ã¡ã‡', 'ì´ˆ': 'ã¡ã‚‡', 'ìµ¸': 'ã¡ã‚‡', 'ì¶”': 'ã¡ã‚…', 'ì¸„': 'ã¡ã‚…', 'ì¸ ': 'ã¤', 'ì¹˜': 'ã¡', 'ì±„': 'ã¡ã‚ƒã„', 'ì²´': 'ã¡ã‡',
            'ì¹´': 'ã‹', 'ìº¬': 'ãã‚ƒ', 'ì»¤': 'ã‘', 'ì¼œ': 'ãã‡', 'ì½”': 'ã“', 'ì¿„': 'ãã‚‡', 'ì¿ ': 'ã', 'í': 'ãã‚…', 'í¬': 'ã', 'í‚¤': 'ã', 'ìº': 'ã‹ã„', 'ì¼€': 'ã‘',
            'íƒ€': 'ãŸ', 'íƒ¸': 'ã¡ã‚ƒ', 'í„°': 'ã¦', 'í…¨': 'ã¡ã‡', 'í† ': 'ã¨', 'íˆ': 'ã¡ã‚‡', 'íˆ¬': 'ã¤', 'íŠœ': 'ã¡ã‚…', 'íŠ¸': 'ã¤', 'í‹°': 'ã¡', 'íƒœ': 'ãŸã„', 'í…Œ': 'ã¦',
            'íŒŒ': 'ã±', 'í„': 'ã´ã‚ƒ', 'í¼': 'ãº', 'í´': 'ã´ã‡', 'í¬': 'ã½', 'í‘œ': 'ã´ã‚‡', 'í‘¸': 'ã·', 'í“¨': 'ã´ã‚…', 'í”„': 'ã·', 'í”¼': 'ã´', 'íŒ¨': 'ã±ã„', 'í˜': 'ãº',
            'í•˜': 'ã¯', 'í–': 'ã²ã‚ƒ', 'í—ˆ': 'ã¸', 'í˜€': 'ã²ã‡', 'í˜¸': 'ã»', 'íš¨': 'ã²ã‚‡', 'í›„': 'ãµ', 'íœ´': 'ã²ã‚…', 'í': 'ãµ', 'íˆ': 'ã²', 'í•´': 'ã¯ã„', 'í—¤': 'ã¸',
            
            // ë°›ì¹¨ ì²˜ë¦¬ + ì†Œì¿ ì˜¨(ì´‰ìŒ)
            'ê°“': 'ãŒã£', 'ë‚«': 'ãªã£', 'ëŒ“': 'ã ã£', 'ë': 'ã‚‰ã£', 'ë§›': 'ã¾ã£', 'ë°§': 'ã°ã£', 'ì‚¿': 'ã•ã£', 'ì•—': 'ã‚ã£', 'ì£': 'ã–ã£', 'ì°»': 'ã¡ã‚ƒã£', 'ìº£': 'ã‹ã£', 'íƒ“': 'ãŸã£', 'íŒŸ': 'ã±ã£', 'í•«': 'ã¯ã£',
            'ê°–': 'ãŒã£', 'ë‚®': 'ãªã£', 'ë‹«': 'ã ã£', 'ë’': 'ã‚‰ã£', 'ë§': 'ã¾ã£', 'ë°­': 'ã°ã£', 'ìƒ·': 'ã•ã£', 'ì•š': 'ã‚ã£', 'ì¦': 'ã–ã£', 'ì³‡': 'ã¡ã‚ƒã£', 'ìº£': 'ã‹ã£', 'íƒ¯': 'ãŸã£', 'íŒŸ': 'ã±ã£', 'í•«': 'ã¯ã£',
            'ê°': 'ãŒã', 'ë‚™': 'ãªã', 'ë‹¨': 'ã ã‚“', 'ë€': 'ã‚‰ã‚“', 'ë§Œ': 'ã¾ã‚“', 'ë°˜': 'ã°ã‚“', 'ì‚°': 'ã•ã‚“', 'ì•ˆ': 'ã‚ã‚“', 'ì”': 'ã–ã‚“', 'ì°¬': 'ã¡ã‚ƒã‚“', 'ì¹¸': 'ã‹ã‚“', 'íƒ„': 'ãŸã‚“', 'íŒ': 'ã±ã‚“', 'í•œ': 'ã¯ã‚“',
            'ê°•': 'ãŒã‚“', 'ë‚­': 'ãªã‚“', 'ë‹¹': 'ã ã‚“', 'ë‘': 'ã‚‰ã‚“', 'ë§': 'ã¾ã‚“', 'ë°©': 'ã°ã‚“', 'ìƒ': 'ã•ã‚“', 'ì•™': 'ã‚ã‚“', 'ì¥': 'ã–ã‚“', 'ì°½': 'ã¡ã‚ƒã‚“', 'ìº‰': 'ã‹ã‚“', 'íƒ•': 'ãŸã‚“', 'íŒ¡': 'ã±ã‚“', 'í•­': 'ã¯ã‚“',
            
            // ã…‡ ë°›ì¹¨ë„ ã‚“ìœ¼ë¡œ ë³€í™˜ (ì¶”ê°€)
            'ê°•': 'ãŒã‚“', 'ê²½': 'ã’ã‚“', 'ê³µ': 'ã”ã‚“', 'ê¶': 'ãã‚“', 'ê¸': 'ãã‚“', 'ê¹…': 'ãã‚“', 'ê°±': 'ãŒã‚“', 'ê²¡': 'ã’ã‚“',
            'ë‚­': 'ãªã‚“', 'ë„': 'ã­ã‚“', 'ë†': 'ã®ã‚“', 'ëˆ™': 'ã¬ã‚“', 'ëŠ¥': 'ã¬ã‚“', 'ë‹': 'ã«ã‚“', 'ëƒ¥': 'ãªã‚“', 'ë…•': 'ã­ã‚“',
            'ë‹¹': 'ã ã‚“', 'ë©': 'ã§ã‚“', 'ë™': 'ã©ã‚“', 'ë‘¥': 'ã¥ã‚“', 'ë“±': 'ã¥ã‚“', 'ë”©': 'ã¢ã‚“', 'ëŒ•': 'ã ã‚“', 'ë…': 'ã§ã‚“',
            'ë‘': 'ã‚‰ã‚“', 'ë ': 'ã‚Œã‚“', 'ë¡±': 'ã‚ã‚“', 'ë£½': 'ã‚‹ã‚“', 'ë¦‰': 'ã‚‹ã‚“', 'ë§': 'ã‚Šã‚“', 'ëŸ‰': 'ã‚‰ã‚“', 'ë ': 'ã‚Œã‚“',
            'ë§': 'ã¾ã‚“', 'ë©': 'ã‚ã‚“', 'ëª½': 'ã‚‚ã‚“', 'ë­‰': 'ã‚€ã‚“', 'ë¯•': 'ã‚€ã‚“', 'ë°': 'ã¿ã‚“', 'ë§¹': 'ã¾ã‚“', 'ë©©': 'ã‚ã‚“',
            'ë°©': 'ã°ã‚“', 'ë²™': 'ã¹ã‚“', 'ë´‰': 'ã¼ã‚“', 'ë¶•': 'ã¶ã‚“', 'ë¸¡': 'ã¶ã‚“', 'ë¹™': 'ã³ã‚“', 'ë±…': 'ã°ã‚“', 'ë²µ': 'ã¹ã‚“',
            'ìƒ': 'ã•ã‚“', 'ì„±': 'ã›ã‚“', 'ì†¡': 'ãã‚“', 'ìˆ­': 'ã™ã‚“', 'ìŠ¹': 'ã™ã‚“', 'ì‹±': 'ã—ã‚“', 'ìƒ¹': 'ã•ã‚“', 'ì…': 'ã›ã‚“',
            'ì•™': 'ã‚ã‚“', 'ì˜': 'ãˆã‚“', 'ì˜¹': 'ãŠã‚“', 'ì›…': 'ã†ã‚“', 'ì‘': 'ã†ã‚“', 'ì‰': 'ã„ã‚“', 'ì–‘': 'ã‚ã‚“', 'ì—¡': 'ãˆã‚“',
            'ì¥': 'ã–ã‚“', 'ì •': 'ãœã‚“', 'ì¢…': 'ãã‚“', 'ì¤‘': 'ãšã‚“', 'ì¦': 'ãšã‚“', 'ì§•': 'ã˜ã‚“', 'ìŸ': 'ã–ã‚“', 'ì ±': 'ãœã‚“',
            'ì°½': 'ã¡ã‚ƒã‚“', 'ì²­': 'ã¡ã‡ã‚“', 'ì´': 'ã¡ã‚‡ã‚“', 'ì¶©': 'ã¡ã‚…ã‚“', 'ì¸µ': 'ã¡ã‚…ã‚“', 'ì¹­': 'ã¡ã‚“', 'ì±™': 'ã¡ã‚ƒã‚“', 'ì³¥': 'ã¡ã‡ã‚“',
            'ìº‰': 'ã‹ã‚“', 'ì»¹': 'ã‘ã‚“', 'ì½©': 'ã“ã‚“', 'ì¿µ': 'ãã‚“', 'í‚': 'ãã‚“', 'í‚¹': 'ãã‚“', 'ìº¥': 'ã‹ã‚“', 'ì¼±': 'ã‘ã‚“',
            'íƒ•': 'ãŸã‚“', 'í…¡': 'ã¦ã‚“', 'í†µ': 'ã¨ã‚“', 'í‰': 'ã¤ã‚“', 'í‹': 'ã¤ã‚“', 'íŒ…': 'ã¡ã‚“', 'íƒ±': 'ãŸã‚“', 'í…¡': 'ã¦ã‚“',
            'íŒ¡': 'ã±ã‚“', 'í‘': 'ãºã‚“', 'í': 'ã½ã‚“', 'í’': 'ã·ã‚“', 'í”™': 'ã·ã‚“', 'í•‘': 'ã´ã‚“', 'íŒ½': 'ã±ã‚“', 'í­': 'ãºã‚“',
            'í•­': 'ã¯ã‚“', 'í—': 'ã¸ã‚“', 'í™': 'ã»ã‚“', 'í›™': 'ãµã‚“', 'í¥': 'ãµã‚“', 'í': 'ã²ã‚“', 'í–‰': 'ã¯ã‚“', 'í—¹': 'ã¸ã‚“',
            
            // ã„´ ë°›ì¹¨ í™•ì¥ (ë” ë§ì€ ì¡°í•©)
            'ê°„': 'ãŒã‚“', 'ê±´': 'ã’ã‚“', 'ê³¤': 'ã”ã‚“', 'êµ°': 'ãã‚“', 'ê·¼': 'ãã‚“', 'ê¸´': 'ãã‚“', 'ê° ': 'ãŒã‚“', 'ê²': 'ã’ã‚“',
            'ë‚œ': 'ãªã‚“', 'ë„Œ': 'ã­ã‚“', 'ë…¼': 'ã®ã‚“', 'ëˆˆ': 'ã¬ã‚“', 'ëŠ”': 'ã¬ã‚“', 'ë‹Œ': 'ã«ã‚“', 'ë‚¸': 'ãªã‚“', 'ë„¨': 'ã­ã‚“',
            'ë‹¨': 'ã ã‚“', 'ë˜': 'ã§ã‚“', 'ëˆ': 'ã©ã‚“', 'ë‘”': 'ã¥ã‚“', 'ë“ ': 'ã¥ã‚“', 'ë”˜': 'ã¢ã‚“', 'ëŒ„': 'ã ã‚“', 'ë´': 'ã§ã‚“',
            'ë€': 'ã‚‰ã‚“', 'ëŸ°': 'ã‚Œã‚“', 'ë¡ ': 'ã‚ã‚“', 'ë£¬': 'ã‚‹ã‚“', 'ë¥¸': 'ã‚‹ã‚“', 'ë¦°': 'ã‚Šã‚“', 'ëœ': 'ã‚‰ã‚“', 'ë Œ': 'ã‚Œã‚“',
            'ë§Œ': 'ã¾ã‚“', 'ë¨¼': 'ã‚ã‚“', 'ëª¬': 'ã‚‚ã‚“', 'ë¬¸': 'ã‚€ã‚“', 'ë¯„': 'ã‚€ã‚“', 'ë¯¼': 'ã¿ã‚“', 'ë§¨': 'ã¾ã‚“', 'ë©˜': 'ã‚ã‚“',
            'ë°˜': 'ã°ã‚“', 'ë²ˆ': 'ã¹ã‚“', 'ë³¸': 'ã¼ã‚“', 'ë¶„': 'ã¶ã‚“', 'ë¸': 'ã¶ã‚“', 'ë¹ˆ': 'ã³ã‚“', 'ë°´': 'ã°ã‚“', 'ë²¤': 'ã¹ã‚“',
            'ì‚°': 'ã•ã‚“', 'ì„ ': 'ã›ã‚“', 'ì†': 'ãã‚“', 'ìˆœ': 'ã™ã‚“', 'ìŠ¨': 'ã™ã‚“', 'ì‹ ': 'ã—ã‚“', 'ìƒŒ': 'ã•ã‚“', 'ì„¼': 'ã›ã‚“',
            'ì•ˆ': 'ã‚ã‚“', 'ì–¸': 'ãˆã‚“', 'ì˜¨': 'ãŠã‚“', 'ìš´': 'ã†ã‚“', 'ì€': 'ã†ã‚“', 'ì¸': 'ã„ã‚“', 'ì•¤': 'ã‚ã‚“', 'ì—”': 'ãˆã‚“',
            'ì”': 'ã–ã‚“', 'ì „': 'ãœã‚“', 'ì¡´': 'ãã‚“', 'ì¤€': 'ãšã‚“', 'ì¦Œ': 'ãšã‚“', 'ì§„': 'ã˜ã‚“', 'ì°': 'ã–ã‚“', 'ì  ': 'ãœã‚“',
            'ì°¬': 'ã¡ã‚ƒã‚“', 'ì²œ': 'ã¡ã‡ã‚“', 'ì´Œ': 'ã¡ã‚‡ã‚“', 'ì¶˜': 'ã¡ã‚…ã‚“', 'ì¸¤': 'ã¡ã‚…ã‚“', 'ì¹œ': 'ã¡ã‚“', 'ì±ˆ': 'ã¡ã‚ƒã‚“', 'ì²¸': 'ã¡ã‡ã‚“',
            'ì¹¸': 'ã‹ã‚“', 'ì»¨': 'ã‘ã‚“', 'ì½˜': 'ã“ã‚“', 'ì¿¤': 'ãã‚“', 'í°': 'ãã‚“', 'í‚¨': 'ãã‚“', 'ìº”': 'ã‹ã‚“', 'ì¼„': 'ã‘ã‚“',
            'íƒ„': 'ãŸã‚“', 'í„´': 'ã¦ã‚“', 'í†¤': 'ã¨ã‚“', 'íˆ°': 'ã¤ã‚“', 'íŠ¼': 'ã¤ã‚“', 'í‹´': 'ã¡ã‚“', 'íƒ ': 'ãŸã‚“', 'í…': 'ã¦ã‚“',
            'íŒ': 'ã±ã‚“', 'í€': 'ãºã‚“', 'í°': 'ã½ã‚“', 'í‘¼': 'ã·ã‚“', 'í”ˆ': 'ã·ã‚“', 'í•€': 'ã´ã‚“', 'íŒ¬': 'ã±ã‚“', 'íœ': 'ãºã‚“',
            'í•œ': 'ã¯ã‚“', 'í—Œ': 'ã¸ã‚“', 'í˜¼': 'ã»ã‚“', 'í›ˆ': 'ãµã‚“', 'í”': 'ãµã‚“', 'íŒ': 'ã²ã‚“', 'í•¸': 'ã¯ã‚“', 'í—¨': 'ã¸ã‚“',
            
            // ã… ë°›ì¹¨ë„ ã‚“ìœ¼ë¡œ ë³€í™˜ë˜ëŠ” ê²½ìš°ë“¤
            'ê°': 'ãŒã‚“', 'ê²€': 'ã’ã‚“', 'ê³°': 'ã”ã‚“', 'êµ¼': 'ãã‚“', 'ê¸ˆ': 'ãã‚“', 'ê¹€': 'ãã‚“', 'ê°¬': 'ãŒã‚“', 'ê²œ': 'ã’ã‚“',
            'ë‚¨': 'ãªã‚“', 'ë„˜': 'ã­ã‚“', 'ë†ˆ': 'ã®ã‚“', 'ëˆ”': 'ã¬ã‚“', 'ëŠ ': 'ã¬ã‚“', 'ë‹˜': 'ã«ã‚“', 'ëƒ ': 'ãªã‚“', 'ë„´': 'ã­ã‚“',
            'ë‹´': 'ã ã‚“', 'ë¤': 'ã§ã‚“', 'ë”': 'ã©ã‚“', 'ë‘ ': 'ã¥ã‚“', 'ë“¬': 'ã¥ã‚“', 'ë”¤': 'ã¢ã‚“', 'ëŒ': 'ã ã‚“', 'ë€': 'ã§ã‚“',
            'ëŒ': 'ã‚‰ã‚“', 'ëŸ¼': 'ã‚Œã‚“', 'ë¡¬': 'ã‚ã‚“', 'ë£¸': 'ã‚‹ã‚“', 'ë¦„': 'ã‚‹ã‚“', 'ë¦¼': 'ã‚Šã‚“', 'ë¨': 'ã‚‰ã‚“', 'ë ˜': 'ã‚Œã‚“',
            'ë§˜': 'ã¾ã‚“', 'ë©ˆ': 'ã‚ã‚“', 'ëª¸': 'ã‚‚ã‚“', 'ë­„': 'ã‚€ã‚“', 'ë¯': 'ã‚€ã‚“', 'ë°ˆ': 'ã¿ã‚“', 'ë§´': 'ã¾ã‚“', 'ë©¤': 'ã‚ã‚“',
            'ë°¤': 'ã°ã‚“', 'ë²”': 'ã¹ã‚“', 'ë´„': 'ã¼ã‚“', 'ë¶': 'ã¶ã‚“', 'ë¸€': 'ã¶ã‚“', 'ë¹”': 'ã³ã‚“', 'ë°¤': 'ã°ã‚“', 'ë°´': 'ã¹ã‚“',
            'ì‚¼': 'ã•ã‚“', 'ì„¬': 'ã›ã‚“', 'ì†œ': 'ãã‚“', 'ìˆ¨': 'ã™ã‚“', 'ìŠ´': 'ã™ã‚“', 'ì‹¬': 'ã—ã‚“', 'ìƒ˜': 'ã•ã‚“', 'ì…ˆ': 'ã›ã‚“',
            'ì•”': 'ã‚ã‚“', 'ì—„': 'ãˆã‚“', 'ì˜´': 'ãŠã‚“', 'ì›€': 'ã†ã‚“', 'ìŒ': 'ã†ã‚“', 'ì„': 'ã„ã‚“', 'ì–Œ': 'ã‚ã‚“', 'ì— ': 'ãˆã‚“',
            'ì ': 'ã–ã‚“', 'ì ': 'ãœã‚“', 'ì¢€': 'ãã‚“', 'ì¤Œ': 'ãšã‚“', 'ì¦˜': 'ãšã‚“', 'ì§': 'ã˜ã‚“', 'ì¼': 'ã–ã‚“', 'ì ¬': 'ãœã‚“',
            'ì°¸': 'ã¡ã‚ƒã‚“', 'ì²¨': 'ã¡ã‡ã‚“', 'ì´˜': 'ã¡ã‚‡ã‚“', 'ì¶¤': 'ã¡ã‚…ã‚“', 'ì¸°': 'ã¡ã‚…ã‚“', 'ì¹¨': 'ã¡ã‚“', 'ì±”': 'ã¡ã‚ƒã‚“', 'ì³„': 'ã¡ã‡ã‚“',
            'ìº„': 'ã‹ã‚“', 'ì»´': 'ã‘ã‚“', 'ì½¤': 'ã“ã‚“', 'ì¿°': 'ãã‚“', 'í¼': 'ãã‚“', 'í‚´': 'ãã‚“', 'ìº ': 'ã‹ã‚“', 'ì¼': 'ã‘ã‚“',
            'íƒ': 'ãŸã‚“', 'í…€': 'ã¦ã‚“', 'í†°': 'ã¨ã‚“', 'íˆ¼': 'ã¤ã‚“', 'í‹ˆ': 'ã¤ã‚“', 'íŒ€': 'ã¡ã‚“', 'íƒ¬': 'ãŸã‚“', 'í…œ': 'ã¦ã‚“',
            'íŒœ': 'ã±ã‚“', 'íŒ': 'ãºã‚“', 'í¼': 'ã½ã‚“', 'í’ˆ': 'ã·ã‚“', 'í””': 'ã·ã‚“', 'í•Œ': 'ã´ã‚“', 'íŒ¸': 'ã±ã‚“', 'í¨': 'ãºã‚“',
            'í•¨': 'ã¯ã‚“', 'í—˜': 'ã¸ã‚“', 'í™ˆ': 'ã»ã‚“', 'í›”': 'ãµã‚“', 'í ': 'ãµã‚“', 'í˜': 'ã²ã‚“', 'í–„': 'ã¯ã‚“', 'í—´': 'ã¸ã‚“',
            
            // ì†Œì¿ ì˜¨ ì¡°í•©ë“¤ (ì¤‘ìš”!)
            'í‚·': 'ãã£', 'ê¹ƒ': 'ãã£', 'ë‹›': 'ã«ã£', 'ë”§': 'ã¢ã£', 'ë¦¿': 'ã‚Šã£', 'ë°‘': 'ã¿ã£', 'ë¹—': 'ã³ã£', 'ì‹¯': 'ã—ã£', 'ì‡': 'ã„ã£', 'ì§“': 'ã˜ã£', 
            'ì¹«': 'ã¡ã£', 'í‚·': 'ãã£', 'í‹±': 'ã¡ã£', 'í•': 'ã´ã£', 'í›': 'ã²ã£',
            'ì¼“': 'ã‘ã£', 'ê²Ÿ': 'ã’ã£', 'ë„·': 'ã­ã£', 'ëƒ': 'ã§ã£', 'ë ›': 'ã‚Œã£', 'ë©§': 'ã‚ã£', 'ë²³': 'ã¹ã£', 'ì…‹': 'ã›ã£', 'ì—£': 'ãˆã£', 'ì ¯': 'ãœã£',
            'ì³‡': 'ã¡ã‡ã£', 'ì¼“': 'ã‘ã£', 'í…Ÿ': 'ã¦ã£', 'í«': 'ãºã£', 'í—·': 'ã¸ã£',
            'ì½§': 'ã“ã£', 'ê³³': 'ã”ã£', 'ë†‹': 'ã®ã£', 'ë—': 'ã©ã£', 'ë¡¯': 'ã‚ã£', 'ëª»': 'ã‚‚ã£', 'ë´‡': 'ã¼ã£', 'ì†Ÿ': 'ãã£', 'ì˜·': 'ãŠã£', 'ì¢ƒ': 'ãã£',
            'ì´›': 'ã¡ã‚‡ã£', 'ì½§': 'ã“ã£', 'í†³': 'ã¨ã£', 'í¿': 'ã½ã£', 'í™‹': 'ã»ã£',
            'ì¿³': 'ãã£', 'êµ¿': 'ãã£', 'ëˆ—': 'ã¬ã£', 'ë‘£': 'ã¥ã£', 'ë£»': 'ã‚‹ã£', 'ë­‡': 'ã‚€ã£', 'ë¶“': 'ã¶ã£', 'ìˆ¯': 'ã™ã£', 'ì›ƒ': 'ã†ã£', 'ì¤': 'ãšã£',
            'ì¶§': 'ã¡ã‚…ã£', 'ì¿³': 'ãã£', 'ëœ¯': 'ã¤ã£', 'í’‹': 'ã·ã£', 'í›—': 'ãµã£',
            
            // ìš”ìŒ (ã‚‡) ì²˜ë¦¬
            'ê°¸': 'ãã‚ƒ', 'ëƒ': 'ã«ã‚ƒ', 'ëŒœ': 'ã¢ã‚ƒ', 'ë´': 'ã‚Šã‚ƒ', 'ë¨€': 'ã¿ã‚ƒ', 'ë±Œ': 'ã³ã‚ƒ', 'ìƒ¤': 'ã—ã‚ƒ', 'ì•¼': 'ã‚„', 'ìŸˆ': 'ã˜ã‚ƒ', 'ì± ': 'ã¡ã‚ƒ', 'ìº¬': 'ãã‚ƒ', 'íƒ¸': 'ã¡ã‚ƒ', 'í„': 'ã´ã‚ƒ', 'í–': 'ã²ã‚ƒ',
            'ê²¨': 'ãã‡', 'ë…€': 'ã«ã‡', 'ëŒ': 'ã¢ã‡', 'ë ¤': 'ã‚Šã‡', 'ë©°': 'ã¿ã‡', 'ë²¼': 'ã³ã‡', 'ì…”': 'ã—ã‡', 'ì—¬': 'ã„ã‡', 'ì ¸': 'ã˜ã‡', 'ì³': 'ã¡ã‡', 'ì¼œ': 'ãã‡', 'í…¨': 'ã¡ã‡', 'í´': 'ã´ã‡', 'í˜€': 'ã²ã‡',
            'êµ': 'ãã‚‡', 'ë‡¨': 'ã«ã‚‡', 'ë´': 'ã¢ã‚‡', 'ë£Œ': 'ã‚Šã‚‡', 'ë¬˜': 'ã¿ã‚‡', 'ëµ¤': 'ã³ã‚‡', 'ì‡¼': 'ã—ã‚‡', 'ìš”': 'ã‚ˆ', 'ì£ ': 'ã˜ã‚‡', 'ìµ¸': 'ã¡ã‚‡', 'ì¿„': 'ãã‚‡', 'íˆ': 'ã¡ã‚‡', 'í‘œ': 'ã´ã‚‡', 'íš¨': 'ã²ã‚‡',
            'ê·œ': 'ãã‚…', 'ë‰´': 'ã«ã‚…', 'ë“€': 'ã¢ã‚…', 'ë¥˜': 'ã‚Šã‚…', 'ë®¤': 'ã¿ã‚…', 'ë·°': 'ã³ã‚…', 'ìŠˆ': 'ã—ã‚…', 'ìœ ': 'ã‚†', 'ì¥¬': 'ã˜ã‚…', 'ì¸„': 'ã¡ã‚…', 'í': 'ãã‚…', 'íŠœ': 'ã¡ã‚…', 'í“¨': 'ã´ã‚…', 'íœ´': 'ã²ã‚…',
            
            // ì¥ìŒ ì²˜ë¦¬
            'ê°€ì•„': 'ãŒã‚', 'ë‚˜ì•„': 'ãªã‚', 'ë‹¤ì•„': 'ã ã‚', 'ë¼ì•„': 'ã‚‰ã‚', 'ë§ˆì•„': 'ã¾ã‚', 'ë°”ì•„': 'ã°ã‚', 'ì‚¬ì•„': 'ã•ã‚', 'ì•„ì•„': 'ã‚ã‚', 'ìì•„': 'ã–ã‚', 'ì°¨ì•„': 'ã¡ã‚ƒã‚', 'ì¹´ì•„': 'ã‹ã‚', 'íƒ€ì•„': 'ãŸã‚', 'íŒŒì•„': 'ã±ã‚', 'í•˜ì•„': 'ã¯ã‚',
            'ê¸°ì´': 'ãã„', 'ë‹ˆì´': 'ã«ã„', 'ë””ì´': 'ã¢ã„', 'ë¦¬ì´': 'ã‚Šã„', 'ë¯¸ì´': 'ã¿ã„', 'ë¹„ì´': 'ã³ã„', 'ì‹œì´': 'ã—ã„', 'ì´ì´': 'ã„ã„', 'ì§€ì´': 'ã˜ã„', 'ì¹˜ì´': 'ã¡ii', 'í‚¤ì´': 'ãã„', 'í‹°ì´': 'ã¡ã„', 'í”¼ì´': 'ã´ã„', 'íˆì´': 'ã²ã„',
            'êµ¬ìš°': 'ãã†', 'ëˆ„ìš°': 'ã¬ã†', 'ë‘ìš°': 'ã¥ã†', 'ë£¨ìš°': 'ã‚‹ã†', 'ë¬´ìš°': 'ã‚€ã†', 'ë¶€ìš°': 'ã¶ã†', 'ìˆ˜ìš°': 'ã™ã†', 'ìš°ìš°': 'ã†ã†', 'ì£¼ìš°': 'ãšã†', 'ì¶”ìš°': 'ã¡ã‚…ã†', 'ì¿ ìš°': 'ãã†', 'íˆ¬ìš°': 'ã¤ã†', 'í‘¸ìš°': 'ã·ã†', 'í›„ìš°': 'ãµã†',
            'ê²Œì—': 'ã’ãˆ', 'ë„¤ì—': 'ã­ãˆ', 'ë°ì—': 'ã§ãˆ', 'ë ˆì—': 'ã‚Œãˆ', 'ë©”ì—': 'ã‚ãˆ', 'ë² ì—': 'ã¹ãˆ', 'ì„¸ì—': 'ã›ãˆ', 'ì—ì—': 'ãˆãˆ', 'ì œì—': 'ãœãˆ', 'ì²´ì—': 'ã¡ã‡ãˆ', 'ì¼€ì—': 'ã‘ãˆ', 'í…Œì—': 'ã¦ãˆ', 'í˜ì—': 'ãºãˆ', 'í—¤ì—': 'ã¸ãˆ',
            'ê³ ì˜¤': 'ã”ãŠ', 'ë…¸ì˜¤': 'ã®ãŠ', 'ë„ì˜¤': 'ã©ãŠ', 'ë¡œì˜¤': 'ã‚ãŠ', 'ëª¨ì˜¤': 'ã‚‚ãŠ', 'ë³´ì˜¤': 'ã¼ãŠ', 'ì†Œì˜¤': 'ããŠ', 'ì˜¤ì˜¤': 'ãŠãŠ', 'ì¡°ì˜¤': 'ããŠ', 'ì´ˆì˜¤': 'ã¡ã‚‡ãŠ', 'ì½”ì˜¤': 'ã“ãŠ', 'í† ì˜¤': 'ã¨ãŠ', 'í¬ì˜¤': 'ã½ãŠ', 'í˜¸ì˜¤': 'ã»ãŠ'
        };

        function JapaneseStudyApp() {
            const [currentTab, setCurrentTab] = useState('quiz');
            const [words, setWords] = useState({});
            const [currentWord, setCurrentWord] = useState(null);
            const [userAnswer, setUserAnswer] = useState('');
            const [score, setScore] = useState(0);
            const [totalQuestions, setTotalQuestions] = useState(0);
            const [result, setResult] = useState(null);
            const [quizStarted, setQuizStarted] = useState(false);
            const [usedWords, setUsedWords] = useState(new Set()); // ì´ë¯¸ ì¶œì œëœ ë¬¸ì œë“¤
            const [quizCompleted, setQuizCompleted] = useState(false); // í€´ì¦ˆ ì™„ë£Œ ì—¬ë¶€
            const [hideHiragana, setHideHiragana] = useState(false); // íˆë¼ê°€ë‚˜ ê°€ë¦¼ ì—¬ë¶€
            
            // ë‹¨ì–´ì¥ ì„¸íŠ¸ ê´€ë¦¬
            const [wordSets, setWordSets] = useState({}); // ëª¨ë“  ë‹¨ì–´ì¥ ì„¸íŠ¸ë“¤
            const [currentSetId, setCurrentSetId] = useState('default'); // í˜„ì¬ ì„ íƒëœ ì„¸íŠ¸
            const [setNames, setSetNames] = useState({ default: 'ê¸°ë³¸ ë‹¨ì–´ì¥' }); // ì„¸íŠ¸ ì´ë¦„ë“¤
            
            // ë‹¨ì–´ ì¶”ê°€ í¼
            const [newKanji, setNewKanji] = useState('');
            const [newHiragana, setNewHiragana] = useState('');
            const [newKorean, setNewKorean] = useState('');
            const [hangulInput, setHangulInput] = useState('');
            const [convertedHiragana, setConvertedHiragana] = useState('');
            const [kanjiStatus, setKanjiStatus] = useState('');
            const [kanjiCandidates, setKanjiCandidates] = useState([]);
            const [showNotification, setShowNotification] = useState(false);
            const [notificationMessage, setNotificationMessage] = useState('');
            const [notificationType, setNotificationType] = useState('success'); // success, error, warning, info
            
            // ìˆ˜ì • ëª¨ë“œ ê´€ë ¨ ìƒíƒœ
            const [isEditMode, setIsEditMode] = useState(false); // ìˆ˜ì • ëª¨ë“œì¸ì§€ ì—¬ë¶€
            const [editingWordKey, setEditingWordKey] = useState(null); // ìˆ˜ì • ì¤‘ì¸ ë‹¨ì–´ì˜ ì›ë˜ í‚¤
            
            // ì¦ê²¨ì°¾ê¸°/í‘œì‹œ ê´€ë ¨ ìƒíƒœ
            const [favoriteWords, setFavoriteWords] = useState({}); // ì„¸íŠ¸ë³„ ì¦ê²¨ì°¾ê¸° ë‹¨ì–´ë“¤
            const [showFavoritesOnly, setShowFavoritesOnly] = useState(false); // ì¦ê²¨ì°¾ê¸°ë§Œ í‘œì‹œ
            const [quizMode, setQuizMode] = useState('all'); // 'all' | 'favorites'
            const [quizType, setQuizType] = useState('korean'); // 'korean' | 'hiragana' | 'both'
            const [convertedQuizAnswer, setConvertedQuizAnswer] = useState(''); // íˆë¼ê°€ë‚˜ í€´ì¦ˆìš© ë³€í™˜ëœ ë‹µì•ˆ
            
            // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆìš© ìƒíƒœë“¤
            const [userKoreanAnswer, setUserKoreanAnswer] = useState(''); // í•œêµ­ì–´ ë‹µì•ˆ
            const [userHiraganaAnswer, setUserHiraganaAnswer] = useState(''); // íˆë¼ê°€ë‚˜ ë‹µì•ˆ
            const [convertedHiraganaAnswer, setConvertedHiraganaAnswer] = useState(''); // ë³€í™˜ëœ íˆë¼ê°€ë‚˜
            const [bothQuizResult, setBothQuizResult] = useState({ korean: null, hiragana: null }); // ê°ê°ì˜ ì •ë‹µ ì—¬ë¶€
            
            // í€´ì¦ˆ ì„ íƒ UI ìƒíƒœ
            const [selectedRange, setSelectedRange] = useState('all'); // 'all' | 'favorites'
            const [selectedType, setSelectedType] = useState('korean'); // 'korean' | 'hiragana' | 'both' | 'japanese'
            
            // í€´ì¦ˆ ì§„í–‰ ìƒíƒœ
            const [isLoadingNextQuestion, setIsLoadingNextQuestion] = useState(false);
            const [wrongAnswers, setWrongAnswers] = useState([]); // í‹€ë¦° ë¬¸ì œë“¤ ì €ì¥
            const [showWrongAnswers, setShowWrongAnswers] = useState(false); // í‹€ë¦° ë¬¸ì œ ë³´ê¸° ëª¨ë“œ
            const [wrongAnswerFavorites, setWrongAnswerFavorites] = useState({}); // í‹€ë¦° ë¬¸ì œ ì¦ê²¨ì°¾ê¸°
            
            // ì „ì²´ ë‹¨ì–´ì¥ ìƒì„± ê´€ë ¨ ìƒíƒœ
            const [selectedSetsForCombined, setSelectedSetsForCombined] = useState({}); // ì „ì²´ ë‹¨ì–´ì¥ì— í¬í•¨í•  ì„¸íŠ¸ë“¤
            const [showSetSelector, setShowSetSelector] = useState(false); // ì„¸íŠ¸ ì„ íƒ UI í‘œì‹œ

            // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
            useEffect(() => {
                loadAllWordSets();
                loadFavoriteWords();
                loadSelectedSets();
            }, []);

            // í˜„ì¬ ì„¸íŠ¸ê°€ ë³€ê²½ë  ë•Œ ë‹¨ì–´ ì—…ë°ì´íŠ¸
            useEffect(() => {
                if (wordSets[currentSetId]) {
                    setWords(wordSets[currentSetId]);
                }
            }, [currentSetId, wordSets]);

            // ëª¨ë“  ë‹¨ì–´ì¥ ì„¸íŠ¸ ë¡œë“œ
            const loadAllWordSets = () => {
                const savedSets = localStorage.getItem('japaneseWordSets');
                const savedSetNames = localStorage.getItem('japaneseSetNames');
                
                if (savedSets && savedSetNames) {
                    try {
                        const parsedSets = JSON.parse(savedSets);
                        const parsedNames = JSON.parse(savedSetNames);
                        setWordSets(parsedSets);
                        setSetNames(parsedNames);
                        
                        // í˜„ì¬ ì„¸íŠ¸ ì„¤ì •
                        const savedCurrentSet = localStorage.getItem('currentWordSet') || 'default';
                        if (parsedSets[savedCurrentSet]) {
                            setCurrentSetId(savedCurrentSet);
                            setWords(parsedSets[savedCurrentSet]);
                        }
                        console.log('ì €ì¥ëœ ë‹¨ì–´ì¥ ì„¸íŠ¸ë“¤ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤:', Object.keys(parsedSets).length + 'ê°œ ì„¸íŠ¸');
                        
                        // ì „ì²´ ë‹¨ì–´ì¥ ìƒì„±
                        setTimeout(() => updateCombinedWordSet(), 100);
                    } catch (error) {
                        console.error('ì €ì¥ëœ ì„¸íŠ¸ ë¡œë“œ ì‹¤íŒ¨:', error);
                        // ê¸°ë³¸ ë¹ˆ ìƒíƒœë¡œ ì´ˆê¸°í™”
                        setWordSets({});
                        setSetNames({});
                        setWords({});
                        setCurrentSetId('');
                    }
                } else {
                    // ê¸°ë³¸ ë¹ˆ ìƒíƒœë¡œ ì´ˆê¸°í™”
                    setWordSets({});
                    setSetNames({});
                    setWords({});
                    setCurrentSetId('');
                }
            };


            // ëª¨ë“  ë‹¨ì–´ì¥ì˜ ë‹¨ì–´ë¥¼ í•©ì¹œ ì „ì²´ ë‹¨ì–´ì¥ ìƒì„±/ì—…ë°ì´íŠ¸
            const updateCombinedWordSet = () => {
                if (Object.keys(wordSets).length === 0) return;
                
                // ì„ íƒëœ ì„¸íŠ¸ë“¤ì˜ ë‹¨ì–´ë¥¼ í•©ì¹¨ (ì„ íƒì´ ì—†ìœ¼ë©´ ëª¨ë“  ì„¸íŠ¸)
                let combinedWords = {};
                const hasSelection = Object.keys(selectedSetsForCombined).some(setId => selectedSetsForCombined[setId]);
                
                Object.entries(wordSets).forEach(([setId, setWords]) => {
                    if (setId !== 'combined') {
                        // ì„ íƒì´ ìˆìœ¼ë©´ ì„ íƒëœ ì„¸íŠ¸ë§Œ, ì—†ìœ¼ë©´ ëª¨ë“  ì„¸íŠ¸
                        if (!hasSelection || selectedSetsForCombined[setId]) {
                            Object.assign(combinedWords, setWords);
                        }
                    }
                });
                
                // í•©ì¹œ ë‹¨ì–´ê°€ ìˆìœ¼ë©´ 'combined' ì„¸íŠ¸ ìƒì„±/ì—…ë°ì´íŠ¸
                if (Object.keys(combinedWords).length > 0) {
                    const updatedSets = { ...wordSets, combined: combinedWords };
                    const updatedNames = { ...setNames, combined: 'ì „ì²´ ë‹¨ì–´ì¥' };
                    
                    setWordSets(updatedSets);
                    setSetNames(updatedNames);
                    
                    // í˜„ì¬ ì„¸íŠ¸ê°€ ë¹„ì–´ìˆìœ¼ë©´ combinedë¡œ ì„¤ì •
                    if (!currentSetId || !updatedSets[currentSetId]) {
                        setCurrentSetId('combined');
                        setWords(combinedWords);
                    }
                    
                    saveAllSets(updatedSets, updatedNames, currentSetId || 'combined');
                    console.log('ì „ì²´ ë‹¨ì–´ì¥ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤:', Object.keys(combinedWords).length + 'ê°œ ë‹¨ì–´');
                } else if (wordSets['combined']) {
                    // ë‹¤ë¥¸ ë‹¨ì–´ì¥ì´ ëª¨ë‘ ì‚­ì œë˜ì—ˆìœ¼ë©´ combinedë„ ì‚­ì œ
                    const updatedSets = { ...wordSets };
                    const updatedNames = { ...setNames };
                    delete updatedSets['combined'];
                    delete updatedNames['combined'];
                    
                    setWordSets(updatedSets);
                    setSetNames(updatedNames);
                    
                    if (currentSetId === 'combined') {
                        const remainingSetIds = Object.keys(updatedSets);
                        const newCurrentSet = remainingSetIds.length > 0 ? remainingSetIds[0] : '';
                        setCurrentSetId(newCurrentSet);
                        setWords(newCurrentSet ? updatedSets[newCurrentSet] : {});
                    }
                    
                    saveAllSets(updatedSets, updatedNames, currentSetId !== 'combined' ? currentSetId : '');
                }
            };
            
            // ëª¨ë“  ì„¸íŠ¸ ë°ì´í„° ì €ì¥
            const saveAllSets = (sets, names, currentSet) => {
                localStorage.setItem('japaneseWordSets', JSON.stringify(sets));
                localStorage.setItem('japaneseSetNames', JSON.stringify(names));
                localStorage.setItem('currentWordSet', currentSet);
            };

            // ì¦ê²¨ì°¾ê¸° ë°ì´í„° ë¡œë“œ
            const loadFavoriteWords = () => {
                const savedFavorites = localStorage.getItem('japaneseFavoriteWords');
                if (savedFavorites) {
                    try {
                        const parsedFavorites = JSON.parse(savedFavorites);
                        setFavoriteWords(parsedFavorites);
                        console.log('ì¦ê²¨ì°¾ê¸° ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                    } catch (error) {
                        console.error('ì¦ê²¨ì°¾ê¸° ë¡œë“œ ì‹¤íŒ¨:', error);
                        setFavoriteWords({});
                    }
                }
            };

            // ì¦ê²¨ì°¾ê¸° ë°ì´í„° ì €ì¥
            const saveFavoriteWords = (favorites) => {
                localStorage.setItem('japaneseFavoriteWords', JSON.stringify(favorites));
                console.log('ì¦ê²¨ì°¾ê¸° ë°ì´í„°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            };

            // ì „ì²´ ë‹¨ì–´ì¥ì— ì„ íƒëœ ì„¸íŠ¸ë“¤ ë¡œë“œ
            const loadSelectedSets = () => {
                const savedSelection = localStorage.getItem('selectedSetsForCombined');
                if (savedSelection) {
                    try {
                        const parsedSelection = JSON.parse(savedSelection);
                        setSelectedSetsForCombined(parsedSelection);
                        console.log('ì „ì²´ ë‹¨ì–´ì¥ ì„¸íŠ¸ ì„ íƒì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } catch (error) {
                        console.error('ì„¸íŠ¸ ì„ íƒ ë¡œë“œ ì‹¤íŒ¨:', error);
                        setSelectedSetsForCombined({});
                    }
                }
            };

            // ì „ì²´ ë‹¨ì–´ì¥ì— ì„ íƒëœ ì„¸íŠ¸ë“¤ ì €ì¥
            const saveSelectedSets = (selection) => {
                localStorage.setItem('selectedSetsForCombined', JSON.stringify(selection));
                console.log('ì „ì²´ ë‹¨ì–´ì¥ ì„¸íŠ¸ ì„ íƒì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            };

            // ë‹¨ì–´ ì¦ê²¨ì°¾ê¸° í† ê¸€
            const toggleWordFavorite = (wordKey) => {
                const currentSetFavorites = favoriteWords[currentSetId] || {};
                const isCurrentlyFavorite = currentSetFavorites[wordKey];

                const updatedFavorites = {
                    ...favoriteWords,
                    [currentSetId]: {
                        ...currentSetFavorites,
                        [wordKey]: !isCurrentlyFavorite
                    }
                };

                // falseì¸ í•­ëª©ë“¤ì€ ì œê±° (ì •ë¦¬)
                if (!updatedFavorites[currentSetId][wordKey]) {
                    delete updatedFavorites[currentSetId][wordKey];
                }

                setFavoriteWords(updatedFavorites);
                saveFavoriteWords(updatedFavorites);

                const action = !isCurrentlyFavorite ? 'í‘œì‹œ' : 'í•´ì œ';
                showAlert(`â­ '${wordKey}' ë‹¨ì–´ë¥¼ ${action}í–ˆìŠµë‹ˆë‹¤.`, 'info');
            };

            // í˜„ì¬ ì„¸íŠ¸ì˜ ì¦ê²¨ì°¾ê¸° ë‹¨ì–´ë“¤ ê°€ì ¸ì˜¤ê¸°
            const getCurrentSetFavorites = () => {
                return favoriteWords[currentSetId] || {};
            };

            // ì¦ê²¨ì°¾ê¸°ëœ ë‹¨ì–´ë§Œ í•„í„°ë§
            const getFilteredWords = () => {
                if (!showFavoritesOnly) return words;
                
                const currentFavorites = getCurrentSetFavorites();
                const filteredWords = {};
                
                Object.keys(words).forEach(wordKey => {
                    if (currentFavorites[wordKey]) {
                        filteredWords[wordKey] = words[wordKey];
                    }
                });
                
                return filteredWords;
            };

            // í˜„ì¬ ì„¸íŠ¸ì˜ ë‹¨ì–´ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì €ì¥ ë° ì „ì²´ ë‹¨ì–´ì¥ ì—…ë°ì´íŠ¸
            useEffect(() => {
                if (Object.keys(words).length > 0 && wordSets[currentSetId] && currentSetId !== 'combined') {
                    const updatedSets = {
                        ...wordSets,
                        [currentSetId]: words
                    };
                    setWordSets(updatedSets);
                    saveAllSets(updatedSets, setNames, currentSetId);
                    console.log(`'${setNames[currentSetId]}' ì„¸íŠ¸ê°€ ìë™ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:`, Object.keys(words).length + 'ê°œ ë‹¨ì–´');
                }
            }, [words]);
            
            // wordSetsê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì „ì²´ ë‹¨ì–´ì¥ ì—…ë°ì´íŠ¸
            useEffect(() => {
                updateCombinedWordSet();
            }, [wordSets, setNames, currentSetId]);

            // íˆë¼ê°€ë‚˜ ì…ë ¥ ì‹œ í•œì ìë™ ê²€ìƒ‰ (API ì‚¬ìš©)
            useEffect(() => {
                const searchKanji = async () => {
                    if (newHiragana) {
                        const foundKanji = await findKanjiForWord(newHiragana);
                        if (foundKanji) {
                            setNewKanji(foundKanji);
                        }
                    } else {
                        setNewKanji('');
                        setKanjiStatus('');
                    }
                };
                
                // ë””ë°”ìš´ìŠ¤ ì²˜ë¦¬ (500ms í›„ì— ê²€ìƒ‰)
                const timeoutId = setTimeout(searchKanji, 500);
                return () => clearTimeout(timeoutId);
            }, [newHiragana]);

            // ë³µì¡í•œ í•œê¸€ â†’ íˆë¼ê°€ë‚˜ ë³€í™˜ (ì†Œì¿ ì˜¨ ì²˜ë¦¬ ê°œì„ )
            const convertHangulToHiragana = useCallback((hangul) => {
                let result = '';
                let i = 0;
                
                while (i < hangul.length) {
                    let found = false;
                    
                    // 4ê¸€ì ì¡°í•© í™•ì¸ (ì˜ˆ: "í‚¤í† ")
                    if (i + 3 < hangul.length) {
                        const four = hangul.substr(i, 4);
                        if (hangulToHiragana[four]) {
                            result += hangulToHiragana[four];
                            i += 4;
                            found = true;
                        }
                    }
                    
                    // 3ê¸€ì ì¡°í•© í™•ì¸ (ì˜ˆ: "í‚·í† ", "ìµ¸í† ")
                    if (!found && i + 2 < hangul.length) {
                        const three = hangul.substr(i, 3);
                        if (hangulToHiragana[three]) {
                            result += hangulToHiragana[three];
                            i += 3;
                            found = true;
                        }
                    }
                    
                    // 2ê¸€ì ì¡°í•© í™•ì¸ (ì˜ˆ: "í‚·", "ìš”ìŒ")
                    if (!found && i + 1 < hangul.length) {
                        const two = hangul.substr(i, 2);
                        if (hangulToHiragana[two]) {
                            result += hangulToHiragana[two];
                            i += 2;
                            found = true;
                        }
                    }
                    
                    // 1ê¸€ì í™•ì¸
                    if (!found) {
                        const one = hangul[i];
                        if (hangulToHiragana[one]) {
                            result += hangulToHiragana[one];
                        } else {
                            // ì†Œì¿ ì˜¨ íŠ¹ë³„ ì²˜ë¦¬: ã……ê°€ ììŒ ì•ì— ì˜¤ë©´ ã£ë¡œ ë³€í™˜
                            if (one === 'ã……' && i + 1 < hangul.length) {
                                const nextChar = hangul[i + 1];
                                // ë‹¤ìŒ ê¸€ìê°€ ììŒìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ê¸€ìë©´ ì†Œì¿ ì˜¨
                                if (['ã„±', 'ã„´', 'ã„·', 'ã„¹', 'ã…', 'ã…‚', 'ã……', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…',
                                     'ã„²', 'ã„¸', 'ã…ƒ', 'ã…†', 'ã…‰'].includes(nextChar) ||
                                    ['ê°€', 'ë‚˜', 'ë‹¤', 'ë¼', 'ë§ˆ', 'ë°”', 'ì‚¬', 'ì', 'ì°¨', 'ì¹´', 'íƒ€', 'íŒŒ', 'í•˜',
                                     'ê¸°', 'ë‹ˆ', 'ë””', 'ë¦¬', 'ë¯¸', 'ë¹„', 'ì‹œ', 'ì§€', 'ì¹˜', 'í‚¤', 'í‹°', 'í”¼', 'íˆ',
                                     'êµ¬', 'ëˆ„', 'ë‘', 'ë£¨', 'ë¬´', 'ë¶€', 'ìˆ˜', 'ì£¼', 'ì¶”', 'ì¿ ', 'íˆ¬', 'í‘¸', 'í›„',
                                     'ê²Œ', 'ë„¤', 'ë°', 'ë ˆ', 'ë©”', 'ë² ', 'ì„¸', 'ì œ', 'ì²´', 'ì¼€', 'í…Œ', 'í˜', 'í—¤',
                                     'ê³ ', 'ë…¸', 'ë„', 'ë¡œ', 'ëª¨', 'ë³´', 'ì†Œ', 'ì¡°', 'ì´ˆ', 'ì½”', 'í† ', 'í¬', 'í˜¸'].some(char => nextChar.startsWith(char))) {
                                    result += 'ã£';
                                } else {
                                    result += one; // ë³€í™˜í•  ìˆ˜ ì—†ëŠ” ë¬¸ìëŠ” ê·¸ëŒ€ë¡œ
                                }
                            } else {
                                result += one; // ë³€í™˜í•  ìˆ˜ ì—†ëŠ” ë¬¸ìëŠ” ê·¸ëŒ€ë¡œ
                            }
                        }
                        i += 1;
                    }
                }
                
                return result;
            }, []);

            // í•œê¸€ ì…ë ¥ ì‹œ ìë™ ë³€í™˜
            useEffect(() => {
                if (hangulInput) {
                    const converted = convertHangulToHiragana(hangulInput);
                    setConvertedHiragana(converted);
                } else {
                    setConvertedHiragana('');
                }
            }, [hangulInput, convertHangulToHiragana]);

            // íˆë¼ê°€ë‚˜ í€´ì¦ˆìš© ì‹¤ì‹œê°„ í•œê¸€ ë³€í™˜
            useEffect(() => {
                if (quizType === 'hiragana' && userAnswer) {
                    const converted = convertHangulToHiragana(userAnswer);
                    setConvertedQuizAnswer(converted);
                } else {
                    setConvertedQuizAnswer('');
                }
            }, [userAnswer, quizType, convertHangulToHiragana]);

            // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆìš© íˆë¼ê°€ë‚˜ ì‹¤ì‹œê°„ ë³€í™˜
            useEffect(() => {
                if (quizType === 'both' && userHiraganaAnswer) {
                    const converted = convertHangulToHiragana(userHiraganaAnswer);
                    setConvertedHiraganaAnswer(converted);
                } else {
                    setConvertedHiraganaAnswer('');
                }
            }, [userHiraganaAnswer, quizType, convertHangulToHiragana]);

            // APIë¥¼ í†µí•œ í•œì ê²€ìƒ‰ (ì—¬ëŸ¬ í›„ë³´ ë°˜í™˜)
            const searchKanjiAPI = async (hiragana) => {
                try {
                    setKanjiStatus('ğŸ” í•œì í›„ë³´ ê²€ìƒ‰ ì¤‘...');
                    setKanjiCandidates([]);
                    
                    // ì—¬ëŸ¬ CORS í”„ë¡ì‹œ ì„œë¹„ìŠ¤ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹œë„
                    const proxies = [
                        'https://api.codetabs.com/v1/proxy?quest=',
                        'https://cors-proxy.htmldriven.com/?url=',
                        'https://cors.bridged.cc/',
                        'https://api.allorigins.win/raw?url='
                    ];
                    
                    const jishoUrl = `https://jisho.org/api/v1/search/words?keyword=${encodeURIComponent(hiragana)}`;
                    let data = null;
                    
                    // ê° í”„ë¡ì‹œë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹œë„
                    for (const proxy of proxies) {
                        try {
                            console.log(`í”„ë¡ì‹œ ì‹œë„: ${proxy}`);
                            const response = await fetch(proxy + encodeURIComponent(jishoUrl), {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                },
                                timeout: 10000 // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
                            });
                            
                            if (response.ok) {
                                const responseText = await response.text();
                                // JSONì¸ì§€ í™•ì¸
                                if (responseText.trim().startsWith('{')) {
                                    data = JSON.parse(responseText);
                                    if (data.data) {
                                        console.log(`ì„±ê³µí•œ í”„ë¡ì‹œ: ${proxy}`);
                                        break;
                                    }
                                }
                            }
                        } catch (proxyError) {
                            console.log(`í”„ë¡ì‹œ ${proxy} ì‹¤íŒ¨:`, proxyError.message);
                            continue;
                        }
                    }
                    
                    console.log('API ì‘ë‹µ:', data); // ë””ë²„ê¹…ìš©
                    
                    if (data && data.data && data.data.length > 0) {
                        const candidates = [];
                        
                        // ëª¨ë“  ê²°ê³¼ì—ì„œ í•œì í›„ë³´ë“¤ ìˆ˜ì§‘
                        for (let entry of data.data.slice(0, 8)) { // ìµœëŒ€ 8ê°œë§Œ
                            if (entry.japanese && entry.japanese.length > 0) {
                                for (let japanese of entry.japanese) {
                                    // í•œìê°€ ìˆê³ , íˆë¼ê°€ë‚˜ì™€ ë‹¤ë¥¸ ê²½ìš°ë§Œ
                                    if (japanese.word && 
                                        japanese.word !== hiragana && 
                                        /[\u4e00-\u9faf]/.test(japanese.word) &&
                                        !candidates.some(c => c.kanji === japanese.word)) {
                                        
                                        // ì˜ì–´ ëœ» ì¶”ê°€
                                        const meanings = entry.senses && entry.senses[0] && entry.senses[0].english_definitions
                                            ? entry.senses[0].english_definitions.slice(0, 3).join(', ')
                                            : '';
                                        
                                        candidates.push({
                                            kanji: japanese.word,
                                            reading: japanese.reading || hiragana,
                                            meanings: meanings
                                        });
                                    }
                                }
                            }
                        }
                        
                        if (candidates.length > 0) {
                            setKanjiCandidates(candidates);
                            setKanjiStatus(`âœ… ${candidates.length}ê°œì˜ í•œì í›„ë³´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤`);
                            return candidates[0].kanji; // ì²« ë²ˆì§¸ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ
                        }
                    }
                    
                    // ëª¨ë“  í”„ë¡ì‹œê°€ ì‹¤íŒ¨í•œ ê²½ìš° ì§ì ‘ API í˜¸ì¶œ ì‹œë„ (CORS ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆì§€ë§Œ ì‹œë„í•´ë³¼ ê°€ì¹˜ê°€ ìˆìŒ)
                    console.log('ëª¨ë“  í”„ë¡ì‹œ ì‹¤íŒ¨, ì§ì ‘ API í˜¸ì¶œ ì‹œë„ ì¤‘...');
                    try {
                        const directResponse = await fetch(`https://jisho.org/api/v1/search/words?keyword=${encodeURIComponent(hiragana)}`, {
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json',
                            }
                        });
                        
                        if (directResponse.ok) {
                            const directData = await directResponse.json();
                            if (directData.data && directData.data.length > 0) {
                                const candidates = [];
                                
                                for (let entry of directData.data.slice(0, 8)) {
                                    if (entry.japanese && entry.japanese.length > 0) {
                                        for (let japanese of entry.japanese) {
                                            if (japanese.word && 
                                                japanese.word !== hiragana && 
                                                /[\u4e00-\u9faf]/.test(japanese.word) &&
                                                !candidates.some(c => c.kanji === japanese.word)) {
                                                
                                                const meanings = entry.senses && entry.senses[0] && entry.senses[0].english_definitions
                                                    ? entry.senses[0].english_definitions.slice(0, 3).join(', ')
                                                    : '';
                                                
                                                candidates.push({
                                                    kanji: japanese.word,
                                                    reading: japanese.reading || hiragana,
                                                    meanings: meanings
                                                });
                                            }
                                        }
                                    }
                                }
                                
                                if (candidates.length > 0) {
                                    setKanjiCandidates(candidates);
                                    setKanjiStatus(`âœ… ì§ì ‘ API ì„±ê³µ: ${candidates.length}ê°œ í•œì ë°œê²¬`);
                                    return candidates[0].kanji;
                                }
                            }
                        }
                    } catch (directError) {
                        console.error('ì§ì ‘ API í˜¸ì¶œë„ ì‹¤íŒ¨:', directError);
                    }
                    
                    setKanjiStatus('âŒ APIì—ì„œ í•œì í›„ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return '';
                } catch (error) {
                    console.error('API ê²€ìƒ‰ ì „ì²´ ì˜¤ë¥˜:', error);
                    setKanjiStatus('âš ï¸ API ì—°ê²° ì‹¤íŒ¨ - ë‚´ì¥ ì‚¬ì „ ì‚¬ìš©');
                    return '';
                }
            };

            // ê°œì„ ëœ í•œì ê²€ìƒ‰ (API + ë‚´ì¥ ì‚¬ì „)
            const findKanjiForWord = async (hiragana) => {
                // 1ìˆœìœ„: ë‚´ì¥ ì‚¬ì „ì—ì„œ ë¹ ë¥¸ ê²€ìƒ‰
                if (kanjiDict[hiragana]) {
                    setKanjiStatus(`âœ… ë‚´ì¥ ì‚¬ì „ì—ì„œ ë°œê²¬: ${kanjiDict[hiragana]}`);
                    setKanjiCandidates([{ kanji: kanjiDict[hiragana], reading: hiragana, meanings: 'ë‚´ì¥ ì‚¬ì „' }]);
                    return kanjiDict[hiragana];
                }
                
                // 2ìˆœìœ„: API ê²€ìƒ‰ (ì—¬ëŸ¬ í›„ë³´ ë°˜í™˜)
                const apiResult = await searchKanjiAPI(hiragana);
                if (apiResult) {
                    // API ê²°ê³¼ë¥¼ ë‚´ì¥ ì‚¬ì „ì— ì €ì¥í•´ì„œ ë‹¤ìŒë²ˆì—ëŠ” ë” ë¹¨ë¦¬
                    kanjiDict[hiragana] = apiResult;
                    return apiResult;
                }
                
                return '';
            };

            // í•œì í›„ë³´ ì„ íƒ í•¨ìˆ˜
            const selectKanjiCandidate = (candidate) => {
                setNewKanji(candidate.kanji);
                setKanjiStatus(`âœ… ì„ íƒë¨: ${candidate.kanji} (${candidate.meanings})`);
                // ì„ íƒëœ ê²°ê³¼ë¥¼ ë‚´ì¥ ì‚¬ì „ì— ì €ì¥
                kanjiDict[newHiragana] = candidate.kanji;
            };

            // ì„¸íŠ¸ ê´€ë¦¬ í•¨ìˆ˜ë“¤
            const createNewSet = async () => {
                // ê°„ë‹¨í•œ prompt ì‚¬ìš©
                const setName = prompt('ìƒˆ ë‹¨ì–´ì¥ì˜ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”:');
                
                if (setName && setName.trim()) {
                    const newSetId = Date.now().toString();
                    const updatedSets = { ...wordSets, [newSetId]: {} };
                    const updatedNames = { ...setNames, [newSetId]: setName.trim() };
                    
                    setWordSets(updatedSets);
                    setSetNames(updatedNames);
                    saveAllSets(updatedSets, updatedNames, currentSetId);
                    
                    showAlert(`ğŸ“š '${setName.trim()}' ë‹¨ì–´ì¥ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
                }
            };

            const switchToSet = (setId) => {
                if (wordSets[setId]) {
                    setCurrentSetId(setId);
                    setWords(wordSets[setId]);
                    localStorage.setItem('currentWordSet', setId);
                    showAlert(`ğŸ“– '${setNames[setId]}' ë‹¨ì–´ì¥ìœ¼ë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤.`, 'info');
                }
            };

            const deleteSet = async (setId) => {
                if (setId === 'combined') {
                    showAlert('ì „ì²´ ë‹¨ì–´ì¥ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ìë™ ìƒì„±ë˜ëŠ” ë‹¨ì–´ì¥ì…ë‹ˆë‹¤)', 'warning');
                    return;
                }

                const confirmed = await showCustomPopup(
                    `ì •ë§ë¡œ '${setNames[setId]}' ë‹¨ì–´ì¥ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì‚­ì œëœ ë‹¨ì–´ì¥ì€ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
                    'ë‹¨ì–´ì¥ ì‚­ì œ í™•ì¸',
                    'danger',
                    true
                );

                if (confirmed) {
                    const updatedSets = { ...wordSets };
                    const updatedNames = { ...setNames };
                    delete updatedSets[setId];
                    delete updatedNames[setId];

                    // í˜„ì¬ ì„¸íŠ¸ê°€ ì‚­ì œë˜ëŠ” ê²½ìš° ë‹¤ë¥¸ ì„¸íŠ¸ë¡œ ì „í™˜
                    let newCurrentSet = currentSetId;
                    if (setId === currentSetId) {
                        const remainingSetIds = Object.keys(updatedSets);
                        newCurrentSet = remainingSetIds.length > 0 ? remainingSetIds[0] : '';
                    }
                    
                    setWordSets(updatedSets);
                    setSetNames(updatedNames);
                    if (newCurrentSet !== currentSetId) {
                        setCurrentSetId(newCurrentSet);
                        setWords(newCurrentSet ? updatedSets[newCurrentSet] : {});
                    }
                    
                    saveAllSets(updatedSets, updatedNames, newCurrentSet);
                    showAlert(`ğŸ—‘ï¸ '${setNames[setId]}' ë‹¨ì–´ì¥ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
                }
            };

            // ë°ì´í„° ë°±ì—…/ë³µì› ê¸°ëŠ¥ë“¤
            const exportToJSON = () => {
                const dataToExport = {
                    wordSets: wordSets,
                    setNames: setNames,
                    currentSetId: currentSetId,
                    exportDate: new Date().toISOString(),
                    version: "1.0"
                };
                
                const jsonString = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `japanese_vocabulary_backup_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showAlert('ğŸ“ ë‹¨ì–´ì¥ì´ JSON íŒŒì¼ë¡œ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤!', 'success');
            };

            const importFromJSON = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);
                    
                    if (!importedData.wordSets || !importedData.setNames) {
                        throw new Error('ì˜¬ë°”ë¥´ì§€ ì•Šì€ íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.');
                    }
                    
                    const confirmed = await showCustomPopup(
                        'ë‹¨ì–´ì¥ì„ ê°€ì ¸ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?\n\nê¸°ì¡´ ë°ì´í„°ëŠ” ë°±ì—…ëœ í›„ ìƒˆ ë°ì´í„°ë¡œ êµì²´ë©ë‹ˆë‹¤.',
                        'ë‹¨ì–´ì¥ ê°€ì ¸ì˜¤ê¸° í™•ì¸',
                        'warning',
                        true
                    );
                    
                    if (confirmed) {
                        // ê¸°ì¡´ ë°ì´í„° ë°±ì—…
                        const backupData = {
                            wordSets: wordSets,
                            setNames: setNames,
                            currentSetId: currentSetId,
                            backupDate: new Date().toISOString()
                        };
                        localStorage.setItem('japaneseWordSetsBackup', JSON.stringify(backupData));
                        
                        // ìƒˆ ë°ì´í„° ì ìš©
                        setWordSets(importedData.wordSets);
                        setSetNames(importedData.setNames);
                        
                        const firstSetId = importedData.currentSetId || Object.keys(importedData.wordSets)[0];
                        setCurrentSetId(firstSetId);
                        setWords(importedData.wordSets[firstSetId]);
                        
                        saveAllSets(importedData.wordSets, importedData.setNames, firstSetId);
                        
                        showAlert(`ğŸ‰ ë‹¨ì–´ì¥ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤! (${Object.keys(importedData.wordSets).length}ê°œ ì„¸íŠ¸)`, 'success');
                    }
                } catch (error) {
                    showAlert('âŒ íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
                }
                
                // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
                event.target.value = '';
            };

            const exportToCSV = () => {
                let csvContent = 'Set Name,Kanji,Hiragana,Korean,Favorite\n';
                
                Object.entries(wordSets).forEach(([setId, words]) => {
                    const setName = setNames[setId] || setId;
                    Object.entries(words).forEach(([kanji, data]) => {
                        const row = [
                            `"${setName}"`,
                            `"${kanji}"`,
                            `"${data.hiragana || ''}"`,
                            `"${data.korean || ''}"`,
                            data.favorite ? 'true' : 'false'
                        ].join(',');
                        csvContent += row + '\n';
                    });
                });
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `japanese_vocabulary_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showAlert('ğŸ“Š ë‹¨ì–´ì¥ì´ CSV íŒŒì¼ë¡œ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤!', 'success');
            };

            const importFromCSV = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const lines = text.split('\n').filter(line => line.trim());
                    
                    if (lines.length < 2) {
                        throw new Error('CSV íŒŒì¼ì´ ë¹„ì–´ìˆê±°ë‚˜ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    }
                    
                    const confirmed = await showCustomPopup(
                        'CSV íŒŒì¼ì—ì„œ ë‹¨ì–´ì¥ì„ ê°€ì ¸ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?\n\nìƒˆë¡œìš´ ì„¸íŠ¸ë¡œ ì¶”ê°€ë˜ë©° ê¸°ì¡´ ë°ì´í„°ëŠ” ìœ ì§€ë©ë‹ˆë‹¤.',
                        'CSV ê°€ì ¸ì˜¤ê¸° í™•ì¸',
                        'info',
                        true
                    );
                    
                    if (!confirmed) return;
                    
                    const headers = lines[0].split(',');
                    const newSets = {};
                    const newSetNames = {};
                    
                    for (let i = 1; i < lines.length; i++) {
                        const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                        if (values.length < 4) continue;
                        
                        const [setName, kanji, hiragana, korean, favorite] = values;
                        if (!setName || !kanji) continue;
                        
                        const setId = `imported_${setName.toLowerCase().replace(/[^a-z0-9]/g, '_')}_${Date.now()}`;
                        
                        if (!newSets[setId]) {
                            newSets[setId] = {};
                            newSetNames[setId] = `${setName} (ê°€ì ¸ì˜´)`;
                        }
                        
                        newSets[setId][kanji] = {
                            hiragana: hiragana || '',
                            korean: korean || '',
                            favorite: favorite === 'true'
                        };
                    }
                    
                    if (Object.keys(newSets).length === 0) {
                        throw new Error('ìœ íš¨í•œ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    const updatedSets = { ...wordSets, ...newSets };
                    const updatedNames = { ...setNames, ...newSetNames };
                    
                    setWordSets(updatedSets);
                    setSetNames(updatedNames);
                    saveAllSets(updatedSets, updatedNames, currentSetId);
                    
                    showAlert(`ğŸ“Š CSVì—ì„œ ${Object.keys(newSets).length}ê°œ ì„¸íŠ¸ë¥¼ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤!`, 'success');
                } catch (error) {
                    showAlert('âŒ CSV íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
                }
                
                event.target.value = '';
            };

            const clearAllData = async () => {
                const confirmed = await showCustomPopup(
                    'ì •ë§ë¡œ ëª¨ë“  ë‹¨ì–´ì¥ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì‚­ì œëœ ë°ì´í„°ëŠ” ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nì‚­ì œ ì „ì— ë°±ì—…ì„ ê¶Œì¥í•©ë‹ˆë‹¤!',
                    'ì „ì²´ ë°ì´í„° ì‚­ì œ',
                    'danger',
                    true
                );
                
                if (confirmed) {
                    // ë°±ì—… ìƒì„±
                    const backupData = {
                        wordSets: wordSets,
                        setNames: setNames,
                        currentSetId: currentSetId,
                        deletedDate: new Date().toISOString()
                    };
                    localStorage.setItem('japaneseWordSetsBackup', JSON.stringify(backupData));
                    
                    // ëª¨ë“  ë°ì´í„° ì‚­ì œ
                    localStorage.removeItem('japaneseWordSets');
                    localStorage.removeItem('japaneseSetNames');
                    localStorage.removeItem('currentWordSet');
                    
                    // ê¸°ë³¸ ë¹ˆ ìƒíƒœë¡œ ì´ˆê¸°í™”
                    setWordSets({});
                    setSetNames({});
                    setWords({});
                    setCurrentSetId('');
                    showAlert('ğŸ—‘ï¸ ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. (ë°±ì—… ì €ì¥ë¨)', 'info');
                }
            };

            const restoreBackup = async () => {
                try {
                    const backupData = localStorage.getItem('japaneseWordSetsBackup');
                    if (!backupData) {
                        showAlert('âŒ ë°±ì—… ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                        return;
                    }
                    
                    const parsedBackup = JSON.parse(backupData);
                    
                    const confirmed = await showCustomPopup(
                        `ë°±ì—… ë°ì´í„°ë¥¼ ë³µì›í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\në°±ì—… ë‚ ì§œ: ${new Date(parsedBackup.backupDate || parsedBackup.deletedDate).toLocaleString()}\n\ní˜„ì¬ ë°ì´í„°ëŠ” ë®ì–´ì“°ì—¬ì§‘ë‹ˆë‹¤.`,
                        'ë°±ì—… ë³µì› í™•ì¸',
                        'warning',
                        true
                    );
                    
                    if (confirmed) {
                        setWordSets(parsedBackup.wordSets);
                        setSetNames(parsedBackup.setNames);
                        setCurrentSetId(parsedBackup.currentSetId);
                        setWords(parsedBackup.wordSets[parsedBackup.currentSetId]);
                        
                        saveAllSets(parsedBackup.wordSets, parsedBackup.setNames, parsedBackup.currentSetId);
                        
                        showAlert('ğŸ”„ ë°±ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                    }
                } catch (error) {
                    showAlert('âŒ ë°±ì—… ë³µì› ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
                }
            };

            // ì•Œë¦¼ í‘œì‹œ í•¨ìˆ˜ (ë””ë²„ê¹… ì¶”ê°€)
            const showAlert = (message, type = 'success') => {
                console.log('ì•Œë¦¼ í‘œì‹œ ì‹œë„:', { message, type }); // ë””ë²„ê¹…
                setNotificationMessage(message);
                setNotificationType(type);
                setShowNotification(true);
                
                console.log('ì•Œë¦¼ ìƒíƒœ ì—…ë°ì´íŠ¸ë¨:', { showNotification: true, message, type }); // ë””ë²„ê¹…
                
                // 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ì‚¬ë¼ì§
                setTimeout(() => {
                    setShowNotification(false);
                    console.log('ì•Œë¦¼ ìë™ ë‹«í˜'); // ë””ë²„ê¹…
                }, 3000);
            };

            // íˆë¼ê°€ë‚˜ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
            const hasHiraganaData = (wordKey, targetWords) => {
                if (!targetWords || !targetWords[wordKey]) return false;
                return (targetWords[wordKey]?.hiragana && targetWords[wordKey].hiragana.trim() !== '') || 
                       /^[\u3041-\u3096]+$/.test(wordKey);
            };

            // íˆë¼ê°€ë‚˜ê°€ ìˆëŠ” ë‹¨ì–´ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” í—¬í¼ í•¨ìˆ˜
            const countHiraganaWords = (targetWords) => {
                if (!targetWords) return 0;
                return Object.keys(targetWords).filter(key => hasHiraganaData(key, targetWords)).length;
            };

            const startQuiz = (mode = 'all', type = 'korean') => {
                let targetWords;
                if (mode === 'favorites') {
                    const currentFavorites = getCurrentSetFavorites();
                    targetWords = {};
                    Object.keys(words).forEach(wordKey => {
                        if (currentFavorites[wordKey]) {
                            targetWords[wordKey] = words[wordKey];
                        }
                    });
                } else {
                    targetWords = words;
                }
                
                // íˆë¼ê°€ë‚˜ í€´ì¦ˆë‚˜ ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆì˜ ê²½ìš° íˆë¼ê°€ë‚˜ê°€ ìˆëŠ” ë‹¨ì–´ë§Œ í•„í„°ë§
                if (type === 'hiragana' || type === 'both') {
                    const filteredWords = {};
                    Object.keys(targetWords).forEach(key => {
                        if (hasHiraganaData(key, targetWords)) {
                            filteredWords[key] = targetWords[key];
                        }
                    });
                    targetWords = filteredWords;
                }
                
                if (Object.keys(targetWords).length === 0) {
                    if (type === 'hiragana' || type === 'both') {
                        showAlert('íˆë¼ê°€ë‚˜ê°€ ë“±ë¡ëœ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤! ë¨¼ì € ë‹¨ì–´ì— íˆë¼ê°€ë‚˜ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”. ğŸˆ¶', 'warning');
                    } else if (mode === 'favorites') {
                        showAlert('í‘œì‹œëœ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤! ë¨¼ì € ë‹¨ì–´ì¥ì—ì„œ ë‹¨ì–´ë¥¼ í‘œì‹œí•´ì£¼ì„¸ìš”. â­', 'warning');
                    } else {
                        showAlert('í˜„ì¬ ë‹¨ì–´ì¥ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤! ë¨¼ì € ë‹¨ì–´ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”. ğŸ“š', 'warning');
                    }
                    return;
                }
                
                setQuizMode(mode);
                setQuizType(type);
                setQuizStarted(true);
                setScore(0);
                setTotalQuestions(0);
                setUsedWords(new Set()); // ì¶œì œëœ ë¬¸ì œ ì´ˆê¸°í™”
                setQuizCompleted(false);
                setHideHiragana(true); // íˆë¼ê°€ë‚˜ ê°€ë¦¼ ìƒíƒœ ì´ˆê¸°í™” (ê¸°ë³¸ìœ¼ë¡œ ê°€ë¦¼)
                setConvertedQuizAnswer(''); // ë³€í™˜ëœ ë‹µì•ˆ ì´ˆê¸°í™”
                setIsLoadingNextQuestion(false); // ë¡œë”© ìƒíƒœ ì´ˆê¸°í™”
                setWrongAnswers([]); // í‹€ë¦° ë‹µì•ˆ ëª©ë¡ ì´ˆê¸°í™”
                
                // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆ ìƒíƒœ ì´ˆê¸°í™”
                setUserKoreanAnswer('');
                setUserHiraganaAnswer('');
                setConvertedHiraganaAnswer('');
                setBothQuizResult({ korean: null, hiragana: null });
                
                const modeText = mode === 'favorites' ? 'í‘œì‹œëœ ë‹¨ì–´ë§Œ' : 'ì „ì²´ ë‹¨ì–´';
                const typeText = type === 'hiragana' ? 'íˆë¼ê°€ë‚˜' : type === 'both' ? 'ë‘˜ ë‹¤ ë§ì¶”ê¸°' : type === 'japanese' ? 'ì¼ë³¸ì–´ë¡œ ì“°ê¸°' : 'í•œêµ­ì–´';
                showAlert(`${modeText} ${typeText} í€´ì¦ˆ ì‹œì‘! í™”ì´íŒ…! ğŸŒ`, 'info');
                nextQuestion();
                
                // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆì¼ ë•Œ í•œêµ­ì–´ ì…ë ¥ í•„ë“œì— ìë™ í¬ì»¤ìŠ¤ (ì§€ì—° ì‹¤í–‰)
                if (type === 'both') {
                    setTimeout(() => {
                        const koreanInput = document.querySelector('input[placeholder*="í•œêµ­ì–´"]');
                        if (koreanInput) {
                            koreanInput.focus();
                        }
                    }, 500); // nextQuestion ìˆ˜í–‰ í›„ ì¶©ë¶„íˆ ê¸°ë‹¤ë¦¬ê¸°
                }
            };


            // í€´ì¦ˆ ëŒ€ìƒ ë‹¨ì–´ ê°€ì ¸ì˜¤ê¸°
            const getQuizTargetWords = () => {
                let targetWords = {};
                
                if (quizMode === 'favorites') {
                    const currentFavorites = getCurrentSetFavorites();
                    Object.keys(words).forEach(wordKey => {
                        if (currentFavorites[wordKey]) {
                            targetWords[wordKey] = words[wordKey];
                        }
                    });
                } else {
                    targetWords = words;
                }
                
                // íˆë¼ê°€ë‚˜ í€´ì¦ˆë‚˜ ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆì˜ ê²½ìš° íˆë¼ê°€ë‚˜ê°€ ìˆëŠ” ë‹¨ì–´ë§Œ í•„í„°ë§
                if (quizType === 'hiragana' || quizType === 'both') {
                    const filteredWords = {};
                    Object.keys(targetWords).forEach(key => {
                        // hiragana ì†ì„±ì´ ìˆê±°ë‚˜, í‚¤ ìì²´ê°€ íˆë¼ê°€ë‚˜ì¸ ê²½ìš° í¬í•¨
                        const hasHiragana = (targetWords[key].hiragana && targetWords[key].hiragana.trim() !== '') || 
                                           /^[\u3041-\u3096]+$/.test(key); // íˆë¼ê°€ë‚˜ ë¬¸ì ì²´í¬
                        if (hasHiragana) {
                            filteredWords[key] = targetWords[key];
                        }
                    });
                    return filteredWords;
                }
                
                return targetWords;
            };

            const nextQuestion = () => {
                // ì´ë¯¸ ë¡œë”© ì¤‘ì´ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
                if (isLoadingNextQuestion) return;
                
                setIsLoadingNextQuestion(true);
                
                const targetWords = getQuizTargetWords();
                const wordKeys = Object.keys(targetWords);
                
                // ë‹¨ì–´ê°€ ì—†ìœ¼ë©´ í€´ì¦ˆë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŒ
                if (wordKeys.length === 0) {
                    setQuizCompleted(true);
                    setCurrentWord(null);
                    setIsLoadingNextQuestion(false);
                    return;
                }
                
                // í˜„ì¬ usedWords ìƒíƒœë¥¼ ìµœì‹ ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
                setUsedWords(currentUsedWords => {
                    const availableWords = wordKeys.filter(key => !currentUsedWords.has(key));
                    
                    // ëª¨ë“  ë‹¨ì–´ë¥¼ ë‹¤ í‘¼ ê²½ìš°
                    if (availableWords.length === 0) {
                        setQuizCompleted(true);
                        setCurrentWord(null);
                        const accuracy = totalQuestions > 0 ? Math.round((score / totalQuestions) * 100) : 0;
                        const modeText = quizMode === 'favorites' ? 'í‘œì‹œëœ ë‹¨ì–´' : 'ì „ì²´ ë‹¨ì–´';
                        const typeText = quizType === 'hiragana' ? 'íˆë¼ê°€ë‚˜' : quizType === 'both' ? 'ë‘˜ ë‹¤ ë§ì¶”ê¸°' : quizType === 'japanese' ? 'ì¼ë³¸ì–´ë¡œ ì“°ê¸°' : 'í•œêµ­ì–´';
                        const scoreDisplay = quizType === 'both' ? `${score}ì ` : `${score}ë¬¸ì œ ì •ë‹µ`;
                        
                        const wrongCount = wrongAnswers.length;
                        const wrongText = wrongCount > 0 ? `\n\ní‹€ë¦° ë¬¸ì œ: ${wrongCount}ê°œ` : '';
                        
                        showCustomPopup(
                            `ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ${modeText} ${typeText} í€´ì¦ˆë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤!\n\nì´ ${totalQuestions}ë¬¸ì œ ì¤‘ ${scoreDisplay}\nì •ë‹µë¥ : ${accuracy}%${wrongText}\n\ní€´ì¦ˆë¥¼ ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ 'í€´ì¦ˆ ì¬ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.`,
                            'í€´ì¦ˆ ì™„ë£Œ!',
                            'success'
                        );
                        setIsLoadingNextQuestion(false);
                        return currentUsedWords;
                    }
                    
                    // ì•„ì§ ì¶œì œë˜ì§€ ì•Šì€ ë¬¸ì œ ì¤‘ì—ì„œ ëœë¤ ì„ íƒ
                    const randomKey = availableWords[Math.floor(Math.random() * availableWords.length)];
                    
                    // ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•œ ì¶”ê°€ ê²€ì¦
                    if (currentUsedWords.has(randomKey)) {
                        console.warn('ì¤‘ë³µ ë¬¸ì œ ì„ íƒ ê°ì§€:', randomKey);
                        // ì¬ê·€ì ìœ¼ë¡œ ë‹¤ì‹œ ì„ íƒ (ë¬´í•œë£¨í”„ ë°©ì§€ë¥¼ ìœ„í•´ availableWords ì‚¬ìš©)
                        const alternativeWords = availableWords.filter(key => !currentUsedWords.has(key));
                        if (alternativeWords.length > 0) {
                            const alternativeKey = alternativeWords[0]; // ì²« ë²ˆì§¸ ì‚¬ìš© ê°€ëŠ¥í•œ ë‹¨ì–´ ì„ íƒ
                            setCurrentWord(alternativeKey);
                        } else {
                            setCurrentWord(randomKey); // fallback
                        }
                    } else {
                        setCurrentWord(randomKey);
                    }
                    
                    setUserAnswer('');
                    setResult(null);
                    setConvertedQuizAnswer(''); // ë³€í™˜ëœ ë‹µì•ˆ ì´ˆê¸°í™”
                    
                    // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆ ìƒíƒœ ì´ˆê¸°í™”
                    setUserKoreanAnswer('');
                    setUserHiraganaAnswer('');
                    setConvertedHiraganaAnswer('');
                    setBothQuizResult({ korean: null, hiragana: null });
                    
                    // ë¡œë”© ìƒíƒœ í•´ì œ ë° í¬ì»¤ìŠ¤ ì„¤ì •
                    setTimeout(() => {
                        setIsLoadingNextQuestion(false);
                        // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆì¼ ë•Œ í•œêµ­ì–´ ì…ë ¥ í•„ë“œì— ìë™ í¬ì»¤ìŠ¤
                        if (quizType === 'both') {
                            const koreanInput = document.querySelector('input[placeholder*="í•œêµ­ì–´"]');
                            if (koreanInput) {
                                koreanInput.focus();
                            }
                        }
                    }, 100);
                    
                    return currentUsedWords;
                });
            };

            const checkAnswer = () => {
                if (!currentWord) return;
                
                if (quizType === 'both') {
                    // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆ ë¡œì§
                    checkBothAnswers();
                } else {
                    // ê¸°ì¡´ ë‹¨ì¼ ë‹µì•ˆ í€´ì¦ˆ ë¡œì§
                    checkSingleAnswer();
                }
            };

            const checkSingleAnswer = () => {
                let correct, typeText;
                if (quizType === 'hiragana') {
                    // hiragana ì†ì„±ì´ ìˆìœ¼ë©´ ì‚¬ìš©í•˜ê³ , ì—†ìœ¼ë©´ í‚¤ ìì²´ë¥¼ íˆë¼ê°€ë‚˜ë¡œ ì‚¬ìš©
                    correct = words[currentWord].hiragana || currentWord;
                    typeText = 'íˆë¼ê°€ë‚˜';
                } else if (quizType === 'japanese') {
                    // ì¼ë³¸ì–´ í€´ì¦ˆ: íˆë¼ê°€ë‚˜ í‚¤ ë˜ëŠ” í•œìë¥¼ ì •ë‹µìœ¼ë¡œ
                    correct = (words[currentWord] && words[currentWord].kanji) || currentWord;
                    typeText = 'ì¼ë³¸ì–´';
                } else {
                    correct = words[currentWord] && words[currentWord].korean;
                    typeText = 'í•œêµ­ì–´';
                }
                
                setTotalQuestions(prev => prev + 1);
                
                // ì •ë‹µ/ì˜¤ë‹µ ê´€ê³„ì—†ì´ ì¶œì œëœ ë¬¸ì œë¡œ í‘œì‹œ (ì¤‘ë³µ ë°©ì§€)
                setUsedWords(prev => {
                    const newUsedWords = new Set(prev);
                    newUsedWords.add(currentWord);
                    console.log('ë¬¸ì œ ì¶”ê°€:', currentWord, 'ì´ ì¶œì œ:', newUsedWords.size);
                    return newUsedWords;
                });
                
                // ë‹µì•ˆ ì •ë¦¬ (ê³µë°± ì œê±°)
                let cleanUserAnswer = userAnswer.trim();
                const cleanCorrectAnswer = correct ? correct.trim() : '';
                
                // íˆë¼ê°€ë‚˜ í€´ì¦ˆì¼ ë•Œ í•œê¸€ ì…ë ¥ì„ íˆë¼ê°€ë‚˜ë¡œ ë³€í™˜í•´ì„œ ì²´í¬
                if (quizType === 'hiragana') {
                    const convertedAnswer = convertHangulToHiragana(cleanUserAnswer);
                    // ì›ë³¸ ì…ë ¥ê³¼ ë³€í™˜ëœ ì…ë ¥ ë‘˜ ë‹¤ ì²´í¬
                    if (cleanUserAnswer === cleanCorrectAnswer || convertedAnswer === cleanCorrectAnswer) {
                        setScore(prev => prev + 1);
                        setResult({ type: 'correct', message: 'âœ… ì •ë‹µ!' });
                        showAlert('ğŸ‰ ì •ë‹µì…ë‹ˆë‹¤!', 'success');
                    } else {
                        // í‹€ë¦° ë‹µì•ˆ ê¸°ë¡ (hiragana í€´ì¦ˆ)
                        const wrongItem = {
                            question: currentWord,
                            kanji: words[currentWord] && words[currentWord].kanji,
                            hiragana: (words[currentWord] && words[currentWord].hiragana) || currentWord,
                            korean: words[currentWord] && words[currentWord].korean,
                            userAnswer: userAnswer,
                            correctAnswer: correct,
                            quizType: quizType
                        };
                        setWrongAnswers(prev => [...prev, wrongItem]);
                        
                        setResult({ type: 'incorrect', message: `âŒ í‹€ë ¸ìŠµë‹ˆë‹¤. ì •ë‹µ: ${correct}` });
                        showAlert(`âŒ í‹€ë ¸ì–´ìš”! ì •ë‹µì€ "${correct}" ì…ë‹ˆë‹¤.`, 'error');
                    }
                } else if (quizType === 'japanese') {
                    // ì¼ë³¸ì–´ í€´ì¦ˆ: í•œìì™€ íˆë¼ê°€ë‚˜ ë‘˜ ë‹¤ ì •ë‹µìœ¼ë¡œ ì¸ì •
                    const hiraganaAnswer = (words[currentWord] && words[currentWord].hiragana) || currentWord;
                    const kanjiAnswer = words[currentWord] && words[currentWord].kanji;
                    
                    let isCorrect = false;
                    let correctAnswers = [];
                    
                    // íˆë¼ê°€ë‚˜ ì •ë‹µ ì²´í¬ (í•œêµ­ì–´ ì…ë ¥ë„ íˆë¼ê°€ë‚˜ë¡œ ë³€í™˜í•´ì„œ ì²´í¬)
                    const convertedAnswer = convertHangulToHiragana(cleanUserAnswer);
                    if (cleanUserAnswer === hiraganaAnswer.trim() || convertedAnswer === hiraganaAnswer.trim()) {
                        isCorrect = true;
                    }
                    correctAnswers.push(hiraganaAnswer);
                    
                    // í•œì ì •ë‹µ ì²´í¬ (í•œìê°€ ìˆëŠ” ê²½ìš°)
                    if (kanjiAnswer && kanjiAnswer.trim() !== '') {
                        if (cleanUserAnswer === kanjiAnswer.trim()) {
                            isCorrect = true;
                        }
                        correctAnswers.push(kanjiAnswer);
                    }
                    
                    if (isCorrect) {
                        setScore(prev => prev + 1);
                        setResult({ type: 'correct', message: 'âœ… ì •ë‹µ!' });
                        showAlert('ğŸ‰ ì •ë‹µì…ë‹ˆë‹¤!', 'success');
                    } else {
                        const answerText = correctAnswers.length > 1 ? correctAnswers.join(' / ') : correctAnswers[0];
                        
                        // í‹€ë¦° ë‹µì•ˆ ê¸°ë¡ (japanese í€´ì¦ˆ)
                        const wrongItem = {
                            question: currentWord,
                            kanji: words[currentWord] && words[currentWord].kanji,
                            hiragana: (words[currentWord] && words[currentWord].hiragana) || currentWord,
                            korean: words[currentWord] && words[currentWord].korean,
                            userAnswer: userAnswer,
                            correctAnswer: answerText,
                            quizType: quizType
                        };
                        setWrongAnswers(prev => [...prev, wrongItem]);
                        
                        setResult({ type: 'incorrect', message: `âŒ í‹€ë ¸ìŠµë‹ˆë‹¤. ì •ë‹µ: ${answerText}` });
                        showAlert(`âŒ í‹€ë ¸ì–´ìš”! ì •ë‹µì€ "${answerText}" ì…ë‹ˆë‹¤.`, 'error');
                    }
                } else {
                    // í•œêµ­ì–´ í€´ì¦ˆì¼ ë•ŒëŠ” ê¸°ì¡´ ë¡œì§
                    if (cleanUserAnswer === cleanCorrectAnswer) {
                        setScore(prev => prev + 1);
                        setResult({ type: 'correct', message: 'âœ… ì •ë‹µ!' });
                        showAlert('ğŸ‰ ì •ë‹µì…ë‹ˆë‹¤!', 'success');
                    } else {
                        // í‹€ë¦° ë‹µì•ˆ ê¸°ë¡ (korean í€´ì¦ˆ)
                        const wrongItem = {
                            question: currentWord,
                            kanji: words[currentWord] && words[currentWord].kanji,
                            hiragana: (words[currentWord] && words[currentWord].hiragana) || currentWord,
                            korean: words[currentWord] && words[currentWord].korean,
                            userAnswer: userAnswer,
                            correctAnswer: correct,
                            quizType: quizType
                        };
                        setWrongAnswers(prev => [...prev, wrongItem]);
                        
                        setResult({ type: 'incorrect', message: `âŒ í‹€ë ¸ìŠµë‹ˆë‹¤. ì •ë‹µ: ${correct}` });
                        showAlert(`âŒ í‹€ë ¸ì–´ìš”! ì •ë‹µì€ "${correct}" ì…ë‹ˆë‹¤.`, 'error');
                    }
                }
                
                setTimeout(() => {
                    nextQuestion();
                }, 2000);
            };

            const checkBothAnswers = () => {
                const correctKorean = words[currentWord] && words[currentWord].korean;
                const correctHiragana = (words[currentWord] && words[currentWord].hiragana) || currentWord;
                
                setTotalQuestions(prev => prev + 1);
                
                // ì •ë‹µ/ì˜¤ë‹µ ê´€ê³„ì—†ì´ ì¶œì œëœ ë¬¸ì œë¡œ í‘œì‹œ (ì¤‘ë³µ ë°©ì§€)
                setUsedWords(prev => {
                    const newUsedWords = new Set(prev);
                    newUsedWords.add(currentWord);
                    console.log('ë¬¸ì œ ì¶”ê°€:', currentWord, 'ì´ ì¶œì œ:', newUsedWords.size);
                    return newUsedWords;
                });
                
                // í•œêµ­ì–´ ë‹µì•ˆ ì²´í¬
                const cleanKoreanAnswer = userKoreanAnswer.trim();
                const cleanCorrectKorean = correctKorean ? correctKorean.trim() : '';
                const koreanCorrect = cleanKoreanAnswer === cleanCorrectKorean;
                
                // íˆë¼ê°€ë‚˜ ë‹µì•ˆ ì²´í¬ (í•œê¸€ ì…ë ¥ë„ ë³€í™˜í•´ì„œ ì²´í¬)
                const cleanHiraganaAnswer = userHiraganaAnswer.trim();
                const cleanCorrectHiragana = correctHiragana ? correctHiragana.trim() : '';
                const convertedHiraganaInput = convertHangulToHiragana(cleanHiraganaAnswer);
                const hiraganaCorrect = cleanHiraganaAnswer === cleanCorrectHiragana || convertedHiraganaInput === cleanCorrectHiragana;
                
                // ê²°ê³¼ ì €ì¥
                setBothQuizResult({
                    korean: koreanCorrect,
                    hiragana: hiraganaCorrect
                });
                
                // ì ìˆ˜ ê³„ì‚° (ë‘˜ ë‹¤ ë§ì¶°ì•¼ 1ì , í•˜ë‚˜ë§Œ ë§ì¶”ë©´ 0.5ì )
                if (koreanCorrect && hiraganaCorrect) {
                    setScore(prev => prev + 1);
                    setResult({ type: 'correct', message: 'ğŸ‰ ì™„ë²½! í•œêµ­ì–´ì™€ íˆë¼ê°€ë‚˜ ëª¨ë‘ ì •ë‹µ!' });
                    showAlert('ğŸ‰ ì™„ë²½í•©ë‹ˆë‹¤! ë‘˜ ë‹¤ ì •ë‹µ!', 'success');
                } else if (koreanCorrect || hiraganaCorrect) {
                    setScore(prev => prev + 0.5);
                    const correctPart = koreanCorrect ? 'í•œêµ­ì–´' : 'íˆë¼ê°€ë‚˜';
                    const wrongPart = koreanCorrect ? 'íˆë¼ê°€ë‚˜' : 'í•œêµ­ì–´';
                    const wrongAnswer = koreanCorrect ? correctHiragana : correctKorean;
                    
                    // ë¶€ë¶„ ì •ë‹µë„ í‹€ë¦° ë‹µì•ˆìœ¼ë¡œ ê¸°ë¡ (ì „ì²´ ì •ë‹µì´ ì•„ë‹ˆë¯€ë¡œ)
                    const wrongItem = {
                        question: currentWord,
                        kanji: words[currentWord] && words[currentWord].kanji,
                        hiragana: (words[currentWord] && words[currentWord].hiragana) || currentWord,
                        korean: words[currentWord] && words[currentWord].korean,
                        userAnswer: `í•œêµ­ì–´: ${userKoreanAnswer}, íˆë¼ê°€ë‚˜: ${userHiraganaAnswer}`,
                        correctAnswer: `í•œêµ­ì–´: ${correctKorean}, íˆë¼ê°€ë‚˜: ${correctHiragana}`,
                        quizType: 'both',
                        result: 'partial'
                    };
                    setWrongAnswers(prev => [...prev, wrongItem]);
                    
                    setResult({ 
                        type: 'partial', 
                        message: `âš¡ ë¶€ë¶„ ì •ë‹µ! ${correctPart}ëŠ” ë§ê³ , ${wrongPart}ëŠ” "${wrongAnswer}"` 
                    });
                    showAlert(`âš¡ ë¶€ë¶„ ì •ë‹µ! ${correctPart}ë§Œ ë§ì·„ì–´ìš”. +0.5ì `, 'warning');
                } else {
                    // ë‘˜ ë‹¤ í‹€ë¦° ê²½ìš° ê¸°ë¡
                    const wrongItem = {
                        question: currentWord,
                        kanji: words[currentWord] && words[currentWord].kanji,
                        hiragana: (words[currentWord] && words[currentWord].hiragana) || currentWord,
                        korean: words[currentWord] && words[currentWord].korean,
                        userAnswer: `í•œêµ­ì–´: ${userKoreanAnswer}, íˆë¼ê°€ë‚˜: ${userHiraganaAnswer}`,
                        correctAnswer: `í•œêµ­ì–´: ${correctKorean}, íˆë¼ê°€ë‚˜: ${correctHiragana}`,
                        quizType: 'both',
                        result: 'incorrect'
                    };
                    setWrongAnswers(prev => [...prev, wrongItem]);
                    
                    setResult({ 
                        type: 'incorrect', 
                        message: `âŒ ëª¨ë‘ í‹€ë ¸ìŠµë‹ˆë‹¤. í•œêµ­ì–´: ${correctKorean}, íˆë¼ê°€ë‚˜: ${correctHiragana}` 
                    });
                    showAlert('âŒ ë‘˜ ë‹¤ í‹€ë ¸ì–´ìš”. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!', 'error');
                }
                
                setTimeout(() => {
                    nextQuestion();
                    // ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°€ë©´ì„œ í•œêµ­ì–´ ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
                    setTimeout(() => {
                        const koreanInput = document.querySelector('input[placeholder*="í•œêµ­ì–´"]');
                        if (koreanInput) {
                            koreanInput.focus();
                        }
                    }, 200); // nextQuestion ìˆ˜í–‰ í›„ ì¶©ë¶„íˆ ê¸°ë‹¤ë¦¬ê¸°
                }, 3000); // ë‘˜ ë‹¤ ë§ì¶”ê¸°ëŠ” ê²°ê³¼ë¥¼ ë” ì˜¤ë˜ ë³´ì—¬ì¤Œ
            };

            const addNewWord = async () => {
                if (!newHiragana || !newKorean) {
                    await showCustomPopup('íˆë¼ê°€ë‚˜ì™€ í•œêµ­ì–´ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”!', 'ì…ë ¥ ì˜¤ë¥˜', 'warning');
                    return;
                }

                // ìˆ˜ì • ëª¨ë“œê°€ ì•„ë‹ ë•Œ ì¤‘ë³µ í™•ì¸
                if (!isEditMode && words[newHiragana]) {
                    await showCustomPopup(`'${newHiragana}' íˆë¼ê°€ë‚˜ëŠ” ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤!`, 'ì¤‘ë³µ ì˜¤ë¥˜', 'error');
                    return;
                }

                // ìˆ˜ì • ëª¨ë“œì¼ ë•Œ: íˆë¼ê°€ë‚˜ê°€ ë³€ê²½ë˜ì—ˆê³ , ìƒˆ íˆë¼ê°€ë‚˜ê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°
                if (isEditMode && newHiragana !== editingWordKey && words[newHiragana]) {
                    await showCustomPopup(`'${newHiragana}' íˆë¼ê°€ë‚˜ëŠ” ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤!`, 'ì¤‘ë³µ ì˜¤ë¥˜', 'error');
                    return;
                }

                const newWordData = {
                    kanji: newKanji.trim(),
                    korean: newKorean.trim()
                };

                setWords(prev => {
                    const updatedWords = { ...prev };
                    
                    // ìˆ˜ì • ëª¨ë“œì¼ ë•Œ ê¸°ì¡´ ë‹¨ì–´ ì‚­ì œ (íˆë¼ê°€ë‚˜ê°€ ë³€ê²½ëœ ê²½ìš°)
                    if (isEditMode && newHiragana !== editingWordKey) {
                        delete updatedWords[editingWordKey];
                    }
                    
                    // ìƒˆ ë‹¨ì–´ ì¶”ê°€/ìˆ˜ì •
                    updatedWords[newHiragana] = newWordData;
                    return updatedWords;
                });

                // í¼ ì´ˆê¸°í™”
                const isEdit = isEditMode;
                setNewKanji('');
                setNewHiragana('');
                setNewKorean('');
                setHangulInput('');
                setKanjiStatus('');
                setKanjiCandidates([]);
                setIsEditMode(false);
                setEditingWordKey(null);
                
                if (isEdit) {
                    showCustomPopup('ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤! âœ…', 'ìˆ˜ì • ì™„ë£Œ', 'success');
                    setCurrentTab('words'); // ë‹¨ì–´ì¥ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                } else {
                    showCustomPopup('ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰', 'ì¶”ê°€ ì™„ë£Œ', 'success');
                }
            };

            const useConvertedWord = () => {
                if (convertedHiragana) {
                    setNewHiragana(convertedHiragana);
                }
            };

            // ë‹¨ì–´ ìˆ˜ì • ì‹œì‘ - ë‹¨ì–´ ì¶”ê°€ íƒ­ìœ¼ë¡œ ì´ë™í•˜ì—¬ ìˆ˜ì •
            const startEditWord = (wordKey) => {
                const wordData = words[wordKey];
                
                // ìˆ˜ì • ëª¨ë“œ í™œì„±í™”
                setIsEditMode(true);
                setEditingWordKey(wordKey);
                
                // ê¸°ì¡´ ë°ì´í„°ë¥¼ ì…ë ¥ í•„ë“œì— ì„¤ì •
                setNewHiragana(wordKey);
                setNewKanji(wordData.kanji || '');
                setNewKorean(wordData.korean || '');
                
                // ë‹¨ì–´ ì¶”ê°€ íƒ­ìœ¼ë¡œ ì´ë™
                setCurrentTab('add');
                
                showAlert(`ğŸ“ '${wordKey}' ë‹¨ì–´ë¥¼ ìˆ˜ì • ëª¨ë“œë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤.`, 'info');
            };

            // ìˆ˜ì • ì·¨ì†Œ
            const cancelEdit = () => {
                setIsEditMode(false);
                setEditingWordKey(null);
                setNewKanji('');
                setNewHiragana('');
                setNewKorean('');
                setHangulInput('');
                setKanjiStatus('');
                setKanjiCandidates([]);
                
                showAlert('ìˆ˜ì •ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
            };

            const deleteWord = async (wordKey) => {
                const confirmed = await showCustomPopup(
                    `ì •ë§ë¡œ '${wordKey}' ë‹¨ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì‚­ì œëœ ë‹¨ì–´ëŠ” ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 
                    'ë‹¨ì–´ ì‚­ì œ í™•ì¸', 
                    'danger', 
                    true  // ì·¨ì†Œ ë²„íŠ¼ í‘œì‹œ
                );
                
                if (confirmed) {
                    setWords(prev => {
                        const newWords = { ...prev };
                        delete newWords[wordKey];
                        return newWords;
                    });
                    
                    showAlert(`ğŸ—‘ï¸ '${wordKey}' ë‹¨ì–´ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    if (quizType === 'both') {
                        // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆì—ì„œëŠ” ë‘˜ ë‹¤ ì…ë ¥í–ˆì„ ë•Œë§Œ ì²´í¬
                        if (userKoreanAnswer.trim() && userHiraganaAnswer.trim()) {
                            checkAnswer();
                        }
                    } else {
                        checkAnswer();
                    }
                }
            };

            const handleBothQuizKeyPress = (e, type) => {
                if (e.key === 'Enter') {
                    if (type === 'korean' && userKoreanAnswer.trim() && userHiraganaAnswer.trim()) {
                        checkAnswer();
                    } else if (type === 'hiragana' && userKoreanAnswer.trim() && userHiraganaAnswer.trim()) {
                        checkAnswer();
                    }
                }
            };

            return (
                <div className="app">
                    {/* ì»¤ìŠ¤í…€ ì•Œë¦¼ íŒì—… - ë””ë²„ê¹… */}
                    {console.log('ë Œë”ë§ ì‹œ ì•Œë¦¼ ìƒíƒœ:', { showNotification, notificationMessage, notificationType })}
                    {showNotification && (
                        <div className={`notification ${notificationType}`}>
                            <span>{notificationMessage}</span>
                            <button 
                                className="notification-close"
                                onClick={() => {
                                    console.log('ì•Œë¦¼ ìˆ˜ë™ ë‹«ê¸°');
                                    setShowNotification(false);
                                }}
                            >
                                Ã—
                            </button>
                        </div>
                    )}

                    <header className="header">
                        <div className="logo">
                            ğŸ—¾ ì¼ë³¸ì–´ ë‹¨ì–´ ê³µë¶€
                        </div>
                        
                        {/* ë‹¨ì–´ì¥ ì„¸íŠ¸ ì„ íƒ */}
                        <div style={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: '1rem',
                            background: 'rgba(255, 255, 255, 0.1)',
                            padding: '0.5rem 1rem',
                            borderRadius: '15px',
                            border: '1px solid rgba(255, 255, 255, 0.2)'
                        }}>
                            <select
                                value={currentSetId}
                                onChange={(e) => switchToSet(e.target.value)}
                                style={{
                                    background: 'rgba(255, 255, 255, 0.9)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    borderRadius: '8px',
                                    padding: '0.3rem 0.8rem',
                                    fontSize: '0.9rem',
                                    color: '#2c3e50',
                                    fontWeight: '500'
                                }}
                            >
                                {Object.entries(setNames).map(([setId, setName]) => (
                                    <option key={setId} value={setId}>
                                        ğŸ“š {setName} ({Object.keys(wordSets[setId] || {}).length}ê°œ)
                                    </option>
                                ))}
                            </select>
                            <button
                                onClick={createNewSet}
                                style={{
                                    background: 'rgba(46, 204, 113, 0.8)',
                                    border: 'none',
                                    color: 'white',
                                    padding: '0.3rem 0.8rem',
                                    borderRadius: '8px',
                                    fontSize: '0.8rem',
                                    fontWeight: '500',
                                    cursor: 'pointer',
                                    transition: 'all 0.3s ease'
                                }}
                                onMouseEnter={(e) => e.target.style.background = 'rgba(46, 204, 113, 1)'}
                                onMouseLeave={(e) => e.target.style.background = 'rgba(46, 204, 113, 0.8)'}
                                title="ìƒˆ ë‹¨ì–´ì¥ ë§Œë“¤ê¸°"
                            >
                                â• ìƒˆ ì„¸íŠ¸
                            </button>
                            {currentSetId !== 'default' && (
                                <button
                                    onClick={() => deleteSet(currentSetId)}
                                    style={{
                                        background: 'rgba(231, 76, 60, 0.8)',
                                        border: 'none',
                                        color: 'white',
                                        padding: '0.3rem 0.8rem',
                                        borderRadius: '8px',
                                        fontSize: '0.8rem',
                                        fontWeight: '500',
                                        cursor: 'pointer',
                                        transition: 'all 0.3s ease'
                                    }}
                                    onMouseEnter={(e) => e.target.style.background = 'rgba(231, 76, 60, 1)'}
                                    onMouseLeave={(e) => e.target.style.background = 'rgba(231, 76, 60, 0.8)'}
                                    title="í˜„ì¬ ë‹¨ì–´ì¥ ì‚­ì œ"
                                >
                                    ğŸ—‘ï¸
                                </button>
                            )}
                        </div>

                        <nav className="nav">
                            <button 
                                className={`nav-btn ${currentTab === 'quiz' ? 'active' : ''}`}
                                onClick={() => setCurrentTab('quiz')}
                            >
                                ğŸ“ í€´ì¦ˆ
                            </button>
                            <button 
                                className={`nav-btn ${currentTab === 'words' ? 'active' : ''}`}
                                onClick={() => setCurrentTab('words')}
                            >
                                ğŸ“š ë‹¨ì–´ì¥
                            </button>
                            <button 
                                className={`nav-btn ${currentTab === 'add' ? 'active' : ''}`}
                                onClick={() => setCurrentTab('add')}
                            >
                                â• ë‹¨ì–´ ì¶”ê°€
                            </button>
                            <button 
                                className={`nav-btn ${currentTab === 'data' ? 'active' : ''}`}
                                onClick={() => setCurrentTab('data')}
                            >
                                ğŸ’¾ ë°ì´í„° ê´€ë¦¬
                            </button>
                        </nav>
                    </header>

                    <main className="main">
                        <div className="container">
                            {currentTab === 'quiz' && (
                                <div className="card fade-in">
                                    <div className="score">
                                        ì ìˆ˜: {score}/{totalQuestions}
                                        {quizStarted && !quizCompleted && (
                                            <>
                                                <div style={{ fontSize: '0.9rem', color: '#7f8c8d', marginTop: '0.5rem' }}>
                                                    {quizMode === 'favorites' ? 'â­ í‘œì‹œëœ ë‹¨ì–´' : 'ğŸ“š ì „ì²´ ë‹¨ì–´'} {quizType === 'hiragana' ? 'ğŸˆ¶ íˆë¼ê°€ë‚˜' : quizType === 'both' ? 'ğŸ’¯ ë‘˜ ë‹¤ ë§ì¶”ê¸°' : quizType === 'japanese' ? 'ğŸ—¾ ì¼ë³¸ì–´ë¡œ ì“°ê¸°' : 'ğŸ‡°ğŸ‡· í•œêµ­ì–´'} - 
                                                    ì§„í–‰ë¥ : {usedWords.size}/{Object.keys(getQuizTargetWords()).length} ë¬¸ì œ ì™„ë£Œ
                                                </div>
                                                {currentWord && words[currentWord] && words[currentWord].kanji && words[currentWord].kanji !== currentWord && (
                                                    <div style={{ fontSize: '0.8rem', color: '#3498db', marginTop: '0.3rem' }}>
                                                        ğŸ’¡ ìš°ì¸¡ ìƒë‹¨ {hideHiragana ? 'ğŸ‘ï¸' : 'ğŸ™ˆ'} ë²„íŠ¼ìœ¼ë¡œ íˆë¼ê°€ë‚˜ë¥¼ ê°€ë¦¬ê±°ë‚˜ ë³¼ ìˆ˜ ìˆì–´ìš”!
                                                    </div>
                                                )}
                                            </>
                                        )}
                                    </div>
                                    
                                    {!quizStarted || quizCompleted ? (
                                        <div style={{ textAlign: 'center' }}>
                                            <h2 style={{ marginBottom: '2rem', color: '#2c3e50' }}>
                                                {quizCompleted ? 
                                                    `ğŸ‰ ${quizMode === 'favorites' ? 'í‘œì‹œëœ ë‹¨ì–´' : 'ì „ì²´ ë‹¨ì–´'} ${quizType === 'hiragana' ? 'íˆë¼ê°€ë‚˜' : quizType === 'both' ? 'ë‘˜ ë‹¤ ë§ì¶”ê¸°' : quizType === 'japanese' ? 'ì¼ë³¸ì–´ë¡œ ì“°ê¸°' : 'í•œêµ­ì–´'} í€´ì¦ˆ ì™„ë£Œ! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!` : 
                                                    'ì¼ë³¸ì–´ ë‹¨ì–´ í€´ì¦ˆë¥¼ ì‹œì‘í•´ë³´ì„¸ìš”! ğŸŒ'
                                                }
                                            </h2>
                                            {/* ê¹”ë”í•œ 2ë‹¨ê³„ í€´ì¦ˆ ì„ íƒ UI */}
                                            <div style={{ background: 'rgba(52, 152, 219, 0.05)', padding: '2rem', borderRadius: '16px', border: '1px solid rgba(52, 152, 219, 0.2)' }}>
                                                {/* 1ë‹¨ê³„: í€´ì¦ˆ ë²”ìœ„ ì„ íƒ */}
                                                <div style={{ marginBottom: '2rem' }}>
                                                    <h3 style={{ color: '#2c3e50', marginBottom: '1rem', fontSize: '1.1rem' }}>ğŸ“ í€´ì¦ˆ ë²”ìœ„</h3>
                                                    <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap', justifyContent: 'center' }}>
                                                        <button 
                                                            className={`btn ${selectedRange === 'all' ? 'btn-primary' : 'btn-secondary'}`}
                                                            onClick={() => setSelectedRange('all')}
                                                            style={{ 
                                                                minWidth: '180px',
                                                                background: selectedRange === 'all' ? '#3498db' : '#bdc3c7',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '0.8rem 1.2rem',
                                                                fontWeight: '600',
                                                                transition: 'all 0.2s ease'
                                                            }}
                                                        >
                                                            ğŸ“š ì „ì²´ ë‹¨ì–´ ({Object.keys(words).length}ê°œ)
                                                        </button>
                                                        <button 
                                                            className={`btn ${selectedRange === 'favorites' ? 'btn-primary' : 'btn-secondary'}`}
                                                            onClick={() => setSelectedRange('favorites')}
                                                            disabled={Object.keys(getCurrentSetFavorites()).length === 0}
                                                            style={{ 
                                                                minWidth: '180px',
                                                                background: selectedRange === 'favorites' ? '#3498db' : '#bdc3c7',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '0.8rem 1.2rem',
                                                                fontWeight: '600',
                                                                transition: 'all 0.2s ease',
                                                                opacity: Object.keys(getCurrentSetFavorites()).length === 0 ? 0.5 : 1
                                                            }}
                                                        >
                                                            â­ í‘œì‹œëœ ë‹¨ì–´ë§Œ ({Object.keys(getCurrentSetFavorites()).length}ê°œ)
                                                        </button>
                                                    </div>
                                                </div>

                                                {/* 2ë‹¨ê³„: í€´ì¦ˆ íƒ€ì… ì„ íƒ */}
                                                <div style={{ marginBottom: '2rem' }}>
                                                    <h3 style={{ color: '#2c3e50', marginBottom: '1rem', fontSize: '1.1rem' }}>ğŸ¯ í€´ì¦ˆ íƒ€ì…</h3>
                                                    <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap', justifyContent: 'center' }}>
                                                        <button 
                                                            className={`btn ${selectedType === 'korean' ? 'btn-success' : 'btn-secondary'}`}
                                                            onClick={() => setSelectedType('korean')}
                                                            style={{ 
                                                                minWidth: '150px',
                                                                background: selectedType === 'korean' ? '#27ae60' : '#bdc3c7',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '0.8rem 1rem',
                                                                fontWeight: '600',
                                                                transition: 'all 0.2s ease'
                                                            }}
                                                        >
                                                            ğŸ‡°ğŸ‡· í•œêµ­ì–´ ëœ»
                                                        </button>
                                                        <button 
                                                            className={`btn ${selectedType === 'hiragana' ? 'btn-success' : 'btn-secondary'}`}
                                                            onClick={() => setSelectedType('hiragana')}
                                                            disabled={(() => {
                                                                const targetWords = selectedRange === 'favorites' ? getCurrentSetFavorites() : words;
                                                                return countHiraganaWords(targetWords) === 0;
                                                            })()}
                                                            style={{ 
                                                                minWidth: '150px',
                                                                background: selectedType === 'hiragana' ? '#27ae60' : '#bdc3c7',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '0.8rem 1rem',
                                                                fontWeight: '600',
                                                                transition: 'all 0.2s ease',
                                                                opacity: (() => {
                                                                    const targetWords = selectedRange === 'favorites' ? getCurrentSetFavorites() : words;
                                                                    return countHiraganaWords(targetWords) === 0 ? 0.5 : 1;
                                                                })()
                                                            }}
                                                        >
                                                            ğŸˆ¶ íˆë¼ê°€ë‚˜
                                                        </button>
                                                        <button 
                                                            className={`btn ${selectedType === 'both' ? 'btn-success' : 'btn-secondary'}`}
                                                            onClick={() => setSelectedType('both')}
                                                            disabled={(() => {
                                                                const targetWords = selectedRange === 'favorites' ? getCurrentSetFavorites() : words;
                                                                return countHiraganaWords(targetWords) === 0;
                                                            })()}
                                                            style={{ 
                                                                minWidth: '150px',
                                                                background: selectedType === 'both' ? '#27ae60' : '#bdc3c7',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '0.8rem 1rem',
                                                                fontWeight: '600',
                                                                transition: 'all 0.2s ease',
                                                                opacity: (() => {
                                                                    const targetWords = selectedRange === 'favorites' ? getCurrentSetFavorites() : words;
                                                                    return countHiraganaWords(targetWords) === 0 ? 0.5 : 1;
                                                                })()
                                                            }}
                                                        >
                                                            ğŸ’¯ ë‘˜ ë‹¤ ë§ì¶”ê¸°
                                                        </button>
                                                        <button 
                                                            className={`btn ${selectedType === 'japanese' ? 'btn-success' : 'btn-secondary'}`}
                                                            onClick={() => setSelectedType('japanese')}
                                                            style={{ 
                                                                minWidth: '150px',
                                                                background: selectedType === 'japanese' ? '#27ae60' : '#bdc3c7',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '0.8rem 1rem',
                                                                fontWeight: '600',
                                                                transition: 'all 0.2s ease'
                                                            }}
                                                        >
                                                            ğŸ—¾ ì¼ë³¸ì–´ë¡œ ì“°ê¸°
                                                        </button>
                                                    </div>
                                                </div>

                                                {/* 3ë‹¨ê³„: í€´ì¦ˆ ì‹œì‘ ë²„íŠ¼ */}
                                                <div style={{ textAlign: 'center' }}>
                                                    <button 
                                                        className="btn btn-primary"
                                                        onClick={() => startQuiz(selectedRange, selectedType)}
                                                        style={{ 
                                                            background: 'linear-gradient(45deg, #e74c3c, #c0392b)',
                                                            border: 'none',
                                                            padding: '1rem 2rem',
                                                            fontSize: '1.1rem',
                                                            fontWeight: 'bold',
                                                            minWidth: '200px'
                                                        }}
                                                        disabled={(() => {
                                                            if (selectedType === 'hiragana' || selectedType === 'both') {
                                                                const targetWords = selectedRange === 'favorites' ? getCurrentSetFavorites() : words;
                                                                return countHiraganaWords(targetWords) === 0;
                                                            }
                                                            if (selectedRange === 'favorites') {
                                                                return Object.keys(getCurrentSetFavorites()).length === 0;
                                                            }
                                                            return Object.keys(words).length === 0;
                                                        })()}
                                                    >
                                                        ğŸš€ í€´ì¦ˆ ì‹œì‘í•˜ê¸°
                                                    </button>
                                                </div>
                                                {quizCompleted && (
                                                    <div style={{ marginTop: '1rem', display: 'flex', gap: '1rem', flexWrap: 'wrap', justifyContent: 'center' }}>
                                                        <button 
                                                        className="btn btn-success" 
                                                        onClick={() => {
                                                            const targetWords = getQuizTargetWords();
                                                            const accuracy = totalQuestions > 0 ? Math.round((score / totalQuestions) * 100) : 0;
                                                            const modeText = quizMode === 'favorites' ? 'í‘œì‹œëœ ë‹¨ì–´' : 'ì „ì²´ ë‹¨ì–´';
                                                            const typeText = quizType === 'hiragana' ? 'íˆë¼ê°€ë‚˜' : quizType === 'both' ? 'ë‘˜ ë‹¤ ë§ì¶”ê¸°' : quizType === 'japanese' ? 'ì¼ë³¸ì–´ë¡œ ì“°ê¸°' : 'í•œêµ­ì–´';
                                                            const scoreText = quizType === 'both' ? `ì ìˆ˜: ${score}ì ` : `ì •ë‹µìˆ˜: ${score}ê°œ`;
                                                            showCustomPopup(
                                                                `ğŸ“Š ${modeText} ${typeText} í€´ì¦ˆ ìµœì¢… ê²°ê³¼\n\nì´ ë¬¸ì œìˆ˜: ${Object.keys(targetWords).length}ê°œ\n${scoreText}\nì˜¤ë‹µìˆ˜: ${totalQuestions - score}ê°œ\nì •ë‹µë¥ : ${accuracy}%\n\n${accuracy >= 90 ? 'ğŸ† ì™„ë²½í•©ë‹ˆë‹¤!' : accuracy >= 70 ? 'ğŸ‘ ì˜í–ˆì–´ìš”!' : 'ğŸ’ª ë” ì—°ìŠµí•´ë³´ì„¸ìš”!'}`,
                                                                'ìµœì¢… ì ìˆ˜',
                                                                'info'
                                                            );
                                                        }}
                                                    >
                                                        ğŸ“Š ê²°ê³¼ ë³´ê¸°
                                                    </button>
                                                    {wrongAnswers.length > 0 && (
                                                        <button 
                                                            className="btn btn-warning" 
                                                            onClick={() => {
                                                                setCurrentTab('words');
                                                                setShowWrongAnswers(true);
                                                            }}
                                                        >
                                                            âŒ í‹€ë¦° ë¬¸ì œ í™•ì¸í•˜ê¸° ({wrongAnswers.length}ê°œ)
                                                        </button>
                                                    )}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ) : (
                                        <>
                                            {currentWord && (
                                                <div className="quiz-word">
                                                    {quizType === 'japanese' ? (
                                                        // ì¼ë³¸ì–´ í€´ì¦ˆ: í•œêµ­ì–´ ëœ»ì„ ë¬¸ì œë¡œ í‘œì‹œ
                                                        <div className="korean-question" style={{ 
                                                            fontSize: '2rem', 
                                                            fontWeight: 'bold', 
                                                            color: '#2c3e50',
                                                            textAlign: 'center',
                                                            padding: '2rem'
                                                        }}>
                                                            {words[currentWord] && words[currentWord].korean}
                                                            <div style={{ 
                                                                fontSize: '1rem', 
                                                                color: '#7f8c8d', 
                                                                marginTop: '1rem',
                                                                fontWeight: 'normal'
                                                            }}>
                                                                ğŸ‘‡ ì´ ëœ»ì— í•´ë‹¹í•˜ëŠ” ì¼ë³¸ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        // ê¸°ì¡´ í€´ì¦ˆë“¤: ì¼ë³¸ì–´ë¥¼ ë¬¸ì œë¡œ í‘œì‹œ
                                                        <>
                                                            {words[currentWord] && words[currentWord].kanji && (
                                                                <div className="kanji">{words[currentWord].kanji}</div>
                                                            )}
                                                            <div className="hiragana-container">
                                                                <div className={`hiragana ${hideHiragana ? 'hiragana-hidden' : ''}`}>
                                                                    {currentWord}
                                                                </div>
                                                                {hideHiragana && (
                                                                    <div className="hiragana-overlay">
                                                                        ğŸ‘ï¸íˆë¼ê°€ë‚˜ ë³´ê¸°
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </>
                                                    )}
                                                    {/* í•œìê°€ ìˆì„ ë•Œë§Œ íˆë¼ê°€ë‚˜ ê°€ë¦¼ ë²„íŠ¼ í‘œì‹œ (japanese í€´ì¦ˆì—ì„œëŠ” ì œì™¸) */}
                                                    {quizType !== 'japanese' && words[currentWord] && words[currentWord].kanji && words[currentWord].kanji !== currentWord && (
                                                        <button 
                                                            className="hiragana-toggle-btn"
                                                            onClick={() => setHideHiragana(!hideHiragana)}
                                                            title={hideHiragana ? "íˆë¼ê°€ë‚˜ ë³´ê¸°" : "íˆë¼ê°€ë‚˜ ê°€ë¦¬ê¸°"}
                                                        >
                                                            {hideHiragana ? 'ğŸ‘ï¸' : 'ğŸ™ˆ'}
                                                        </button>
                                                    )}
                                                    
                                                    {/* ì¦ê²¨ì°¾ê¸°/í‘œì‹œ ë²„íŠ¼ */}
                                                    <button 
                                                        className={`quiz-favorite-btn ${getCurrentSetFavorites()[currentWord] ? 'favorited' : ''}`}
                                                        onClick={() => toggleWordFavorite(currentWord)}
                                                        title={getCurrentSetFavorites()[currentWord] ? "í‘œì‹œ í•´ì œ" : "í‘œì‹œ ì¶”ê°€"}
                                                        style={{
                                                            background: getCurrentSetFavorites()[currentWord] ? 
                                                                'linear-gradient(45deg, #f39c12, #e67e22)' : 
                                                                'rgba(189, 195, 199, 0.8)'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            if (getCurrentSetFavorites()[currentWord]) {
                                                                e.target.style.background = 'linear-gradient(45deg, #e67e22, #d35400)';
                                                            } else {
                                                                e.target.style.background = 'rgba(149, 165, 166, 0.9)';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            if (getCurrentSetFavorites()[currentWord]) {
                                                                e.target.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)';
                                                            } else {
                                                                e.target.style.background = 'rgba(189, 195, 199, 0.8)';
                                                            }
                                                        }}
                                                    >
                                                        {getCurrentSetFavorites()[currentWord] ? 'â­' : 'â˜†'}
                                                    </button>
                                                </div>
                                            )}
                                            
                                            {quizType === 'both' ? (
                                                // ë‘˜ ë‹¤ ë§ì¶”ê¸° í€´ì¦ˆìš© UI
                                                <div>
                                                    <div className="input-group" style={{ marginBottom: '1.5rem' }}>
                                                        <label className="input-label">í•œêµ­ì–´ ëœ»:</label>
                                                        <input
                                                            type="text"
                                                            className="input-field"
                                                            value={userKoreanAnswer}
                                                            onChange={(e) => setUserKoreanAnswer(e.target.value)}
                                                            onKeyPress={(e) => handleBothQuizKeyPress(e, 'korean')}
                                                            placeholder="í•œêµ­ì–´ ëœ»ì„ ì…ë ¥í•˜ì„¸ìš”... (ì˜ˆ: í•™êµ)"
                                                            style={{
                                                                border: bothQuizResult.korean === true ? '2px solid #27ae60' :
                                                                       bothQuizResult.korean === false ? '2px solid #e74c3c' :
                                                                       '1px solid #bdc3c7'
                                                            }}
                                                        />
                                                        {bothQuizResult.korean === true && (
                                                            <div style={{ color: '#27ae60', fontSize: '0.8rem', marginTop: '0.3rem' }}>
                                                                âœ… í•œêµ­ì–´ ì •ë‹µ!
                                                            </div>
                                                        )}
                                                        {bothQuizResult.korean === false && (
                                                            <div style={{ color: '#e74c3c', fontSize: '0.8rem', marginTop: '0.3rem' }}>
                                                                âŒ í•œêµ­ì–´ ì˜¤ë‹µ
                                                            </div>
                                                        )}
                                                    </div>
                                                    
                                                    <div className="input-group">
                                                        <label className="input-label">íˆë¼ê°€ë‚˜:</label>
                                                        <input
                                                            type="text"
                                                            className="input-field"
                                                            value={userHiraganaAnswer}
                                                            onChange={(e) => setUserHiraganaAnswer(e.target.value)}
                                                            onKeyPress={(e) => handleBothQuizKeyPress(e, 'hiragana')}
                                                            placeholder="íˆë¼ê°€ë‚˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”... (í•œê¸€ë¡œë„ ê°€ëŠ¥)"
                                                            style={{
                                                                border: bothQuizResult.hiragana === true ? '2px solid #27ae60' :
                                                                       bothQuizResult.hiragana === false ? '2px solid #e74c3c' :
                                                                       '1px solid #bdc3c7'
                                                            }}
                                                        />
                                                        {convertedHiraganaAnswer && userHiraganaAnswer && (
                                                            <div style={{
                                                                marginTop: '0.5rem',
                                                                padding: '0.5rem',
                                                                background: 'rgba(46, 204, 113, 0.1)',
                                                                borderRadius: '8px',
                                                                border: '1px solid rgba(46, 204, 113, 0.3)',
                                                                fontSize: '0.9rem',
                                                                color: '#27ae60'
                                                            }}>
                                                                ğŸ”„ í•œê¸€ â†’ íˆë¼ê°€ë‚˜ ë³€í™˜: <strong>{convertedHiraganaAnswer}</strong>
                                                            </div>
                                                        )}
                                                        {bothQuizResult.hiragana === true && (
                                                            <div style={{ color: '#27ae60', fontSize: '0.8rem', marginTop: '0.3rem' }}>
                                                                âœ… íˆë¼ê°€ë‚˜ ì •ë‹µ!
                                                            </div>
                                                        )}
                                                        {bothQuizResult.hiragana === false && (
                                                            <div style={{ color: '#e74c3c', fontSize: '0.8rem', marginTop: '0.3rem' }}>
                                                                âŒ íˆë¼ê°€ë‚˜ ì˜¤ë‹µ
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            ) : (
                                                // ê¸°ì¡´ ë‹¨ì¼ ë‹µì•ˆ í€´ì¦ˆìš© UI
                                                <div className="input-group">
                                                    <label className="input-label">
                                                        {quizType === 'hiragana' ? 'íˆë¼ê°€ë‚˜:' : 'í•œêµ­ì–´ ëœ»:'}
                                                    </label>
                                                    <input
                                                        type="text"
                                                        className="input-field"
                                                        value={userAnswer}
                                                        onChange={(e) => {
                                                            setUserAnswer(e.target.value);
                                                            // íˆë¼ê°€ë‚˜/ì¼ë³¸ì–´ í€´ì¦ˆì¼ ë•Œ ì‹¤ì‹œê°„ ë³€í™˜ í‘œì‹œ
                                                            if (quizType === 'hiragana' || quizType === 'japanese') {
                                                                const converted = convertHangulToHiragana(e.target.value);
                                                                setConvertedQuizAnswer(converted);
                                                            }
                                                        }}
                                                        onKeyPress={handleKeyPress}
                                                        placeholder={
                                                            quizType === 'hiragana' ? "íˆë¼ê°€ë‚˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”... (í•œê¸€ë¡œë„ ê°€ëŠ¥)" : 
                                                            quizType === 'japanese' ? "ì¼ë³¸ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”... (í•œê¸€ë¡œë„ ê°€ëŠ¥)" :
                                                            "í•œêµ­ì–´ ëœ»ì„ ì…ë ¥í•˜ì„¸ìš”... (ì˜ˆ: ë¨¹ë‹¤)"
                                                        }
                                                    />
                                                    {(quizType === 'hiragana' || quizType === 'japanese') && (
                                                        <div style={{
                                                            marginTop: '0.5rem',
                                                            padding: '0.5rem',
                                                            background: 'rgba(46, 204, 113, 0.1)',
                                                            borderRadius: '8px',
                                                            border: '1px solid rgba(46, 204, 113, 0.3)',
                                                            fontSize: '0.9rem',
                                                            color: '#27ae60'
                                                        }}>
                                                            <div style={{ fontSize: '0.8rem', color: '#666', marginBottom: '0.5rem' }}>
                                                                ğŸ’¡ í•œê¸€ë¡œ ì…ë ¥í•´ë„ ìë™ìœ¼ë¡œ íˆë¼ê°€ë‚˜ë¡œ ë³€í™˜ë˜ì–´ ì±„ì ë©ë‹ˆë‹¤!
                                                            </div>
                                                            <div>
                                                                ğŸ”„ í•œê¸€ â†’ íˆë¼ê°€ë‚˜ ë³€í™˜: <strong>
                                                                    {userAnswer ? convertHangulToHiragana(userAnswer) || userAnswer : '(ì…ë ¥í•˜ë©´ ì—¬ê¸°ì— ë³€í™˜ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤)'}
                                                                </strong>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            )}

                                            {result && (
                                                <div className={`result ${result.type}`}>
                                                    {result.message}
                                                </div>
                                            )}

                                            <div className="btn-group">
                                                <button 
                                                    className="btn btn-success" 
                                                    onClick={checkAnswer}
                                                    disabled={quizType === 'both' && (!userKoreanAnswer.trim() || !userHiraganaAnswer.trim())}
                                                    title={quizType === 'both' && (!userKoreanAnswer.trim() || !userHiraganaAnswer.trim()) ? 
                                                          'í•œêµ­ì–´ì™€ íˆë¼ê°€ë‚˜ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”' : ''}
                                                >
                                                    {quizType === 'both' ? 'ë‘˜ ë‹¤ ì •ë‹µ í™•ì¸' : 'ì •ë‹µ í™•ì¸'}
                                                </button>
                                                <button 
                                                    className="btn btn-warning" 
                                                    onClick={nextQuestion}
                                                    disabled={isLoadingNextQuestion}
                                                >
                                                    {isLoadingNextQuestion ? 'â³ ë¡œë”©ì¤‘...' : 'ë‹¤ìŒ ë¬¸ì œ'}
                                                </button>
                                                <button 
                                                    className="btn btn-danger" 
                                                    onClick={async () => {
                                                        const confirmed = await showCustomPopup(
                                                            'í€´ì¦ˆë¥¼ ì¤‘ë‹¨í•˜ê³  ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?', 
                                                            'í€´ì¦ˆ ì¬ì‹œì‘', 
                                                            'warning', 
                                                            true
                                                        );
                                                        if (confirmed) {
                                                            startQuiz(quizMode, quizType);
                                                        }
                                                    }}
                                                >
                                                    ğŸ”„ ì¬ì‹œì‘
                                                </button>
                                            </div>
                                        </>
                                    )}
                                </div>
                            )}

                            {currentTab === 'words' && (
                                <div className="card fade-in">
                                    {showWrongAnswers ? (
                                        <>
                                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '2rem' }}>
                                                <h2 style={{ color: '#2c3e50', margin: 0 }}>
                                                    âŒ í‹€ë¦° ë¬¸ì œ ë³µìŠµ ({wrongAnswers.length}ê°œ)
                                                </h2>
                                                <button 
                                                    className="btn btn-secondary"
                                                    onClick={() => {
                                                        setShowWrongAnswers(false);
                                                        setWrongAnswerFavorites({});
                                                    }}
                                                >
                                                    ëŒì•„ê°€ê¸°
                                                </button>
                                            </div>
                                            <div style={{
                                                backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                                padding: '1rem',
                                                borderRadius: '8px',
                                                border: '1px solid rgba(231, 76, 60, 0.3)',
                                                marginBottom: '2rem',
                                                fontSize: '0.9rem',
                                                color: '#c0392b'
                                            }}>
                                                ğŸ’¡ í‹€ë¦° ë¬¸ì œë“¤ì„ ë‹¤ì‹œ í•™ìŠµí•´ë³´ì„¸ìš”. â­ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì¤‘ìš”í•œ ë¬¸ì œë¥¼ í‘œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                                            </div>
                                        </>
                                    ) : (
                                        <h2 style={{ marginBottom: '2rem', color: '#2c3e50' }}>
                                            ğŸ“š {setNames[currentSetId]} ({Object.keys(words).length}ê°œ ë‹¨ì–´)
                                        </h2>
                                    )}
                                    <div style={{ 
                                        fontSize: '0.9rem', 
                                        color: '#27ae60', 
                                        marginBottom: '1rem', 
                                        padding: '0.8rem',
                                        backgroundColor: 'rgba(46, 204, 113, 0.1)',
                                        borderRadius: '8px',
                                        border: '1px solid rgba(46, 204, 113, 0.3)'
                                    }}>
                                        ğŸ’¾ í˜„ì¬ '{setNames[currentSetId]}' ë‹¨ì–´ì¥ì´ ì„ íƒë˜ì–´ ìˆìŠµë‹ˆë‹¤. ëª¨ë“  ì„¸íŠ¸ëŠ” ë¸Œë¼ìš°ì €ì— ìë™ ì €ì¥ë©ë‹ˆë‹¤!
                                    </div>
                                    
                                    {!showWrongAnswers && (
                                        <div style={{
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'center',
                                            marginBottom: '1rem',
                                            padding: '0.5rem',
                                            background: 'rgba(52, 152, 219, 0.1)',
                                            borderRadius: '8px',
                                            border: '1px solid rgba(52, 152, 219, 0.3)'
                                        }}>
                                        <div style={{ fontSize: '0.9rem', color: '#2c3e50' }}>
                                            ğŸ“Š ì „ì²´ ì„¸íŠ¸: {Object.keys(setNames).length}ê°œ | 
                                            ì „ì²´ ë‹¨ì–´: {Object.values(wordSets).reduce((total, set) => total + Object.keys(set).length, 0)}ê°œ |
                                            í‘œì‹œëœ ë‹¨ì–´: {Object.keys(getCurrentSetFavorites()).length}ê°œ
                                        </div>
                                        <button
                                            className="btn"
                                            onClick={() => setShowFavoritesOnly(!showFavoritesOnly)}
                                            style={{
                                                padding: '0.3rem 0.8rem',
                                                fontSize: '0.8rem',
                                                background: showFavoritesOnly ? 'linear-gradient(45deg, #f39c12, #e67e22)' : 'linear-gradient(45deg, #bdc3c7, #95a5a6)',
                                                color: 'white',
                                                border: 'none',
                                                borderRadius: '6px'
                                            }}
                                            title={showFavoritesOnly ? "ëª¨ë“  ë‹¨ì–´ ë³´ê¸°" : "í‘œì‹œëœ ë‹¨ì–´ë§Œ ë³´ê¸°"}
                                        >
                                            {showFavoritesOnly ? 'ğŸ“‹ ì „ì²´ ë³´ê¸°' : 'â­ í‘œì‹œë§Œ ë³´ê¸°'}
                                        </button>
                                        </div>
                                    )}
                                    
                                    {showWrongAnswers ? (
                                        <div className="word-list">
                                            {wrongAnswers.map((wrongItem, index) => {
                                                const questionText = wrongItem.kanji || wrongItem.hiragana;
                                                const isFavorite = wrongAnswerFavorites[index];
                                                
                                                // ë©”ì¸ ë‹¨ì–´ì¥ì—ì„œ ì´ë¯¸ í‘œì‹œëœ ë‹¨ì–´ì¸ì§€ í™•ì¸
                                                const wordKey = wrongItem.hiragana || wrongItem.question;
                                                const isAlreadyStarred = getCurrentSetFavorites()[wordKey] || false;
                                                
                                                return (
                                                    <div key={index} className="word-item slide-in" style={{
                                                        border: isAlreadyStarred ? '2px solid #f39c12' : '1px solid #e1e8ed',
                                                        backgroundColor: isAlreadyStarred ? 'rgba(243, 156, 18, 0.05)' : 'rgba(231, 76, 60, 0.02)'
                                                    }}>
                                                        <div>
                                                            <strong style={{ color: isAlreadyStarred ? '#f39c12' : '#2c3e50' }}>
                                                                {isAlreadyStarred ? 'â­ ' : ''}{questionText}
                                                            </strong>
                                                            {wrongItem.kanji && wrongItem.kanji !== wrongItem.hiragana && <span> ({wrongItem.hiragana})</span>}
                                                            <span style={{ color: '#27ae60' }}> - {wrongItem.korean}</span>
                                                            <br/>
                                                            <small style={{ color: '#7f8c8d' }}>
                                                                ë‚´ ë‹µ: <span style={{ color: '#e74c3c' }}>{wrongItem.userAnswer}</span> | 
                                                                ì •ë‹µ: <span style={{ color: '#27ae60' }}>{wrongItem.correctAnswer}</span>
                                                                {wrongItem.result && <span> ({wrongItem.result === 'partial' ? 'ë¶€ë¶„ ì •ë‹µ' : 'ì˜¤ë‹µ'})</span>}
                                                            </small>
                                                        </div>
                                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button 
                                                                className="btn"
                                                                style={{ 
                                                                    padding: '0.5rem 1rem', 
                                                                    fontSize: '0.9rem',
                                                                    background: isAlreadyStarred ? 'linear-gradient(45deg, #f39c12, #e67e22)' : 'linear-gradient(45deg, #bdc3c7, #95a5a6)',
                                                                    color: 'white'
                                                                }}
                                                                onClick={() => {
                                                                    const wordKey = wrongItem.hiragana || wrongItem.question;
                                                                    // ì‹¤ì œ ë‹¨ì–´ì¥ì— ì¦ê²¨ì°¾ê¸° ì¶”ê°€/ì œê±°
                                                                    toggleWordFavorite(wordKey);
                                                                    // ë¡œì»¬ ìƒíƒœë„ ì—…ë°ì´íŠ¸ (í‹€ë¦°ë¬¸ì œ ì „ìš© ì¦ê²¨ì°¾ê¸°ëŠ” ì œê±°)
                                                                    setWrongAnswerFavorites(prev => ({
                                                                        ...prev,
                                                                        [index]: false
                                                                    }));
                                                                }}
                                                                title={isAlreadyStarred ? "í‘œì‹œ í•´ì œ" : "í‘œì‹œ ì¶”ê°€"}
                                                            >
                                                                {isAlreadyStarred ? 'â­ í‘œì‹œë¨' : 'â˜† í‘œì‹œ'}
                                                            </button>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                            {wrongAnswers.length === 0 && (
                                                <div style={{ textAlign: 'center', color: '#7f8c8d', padding: '2rem' }}>
                                                    í‹€ë¦° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤! ğŸ‰
                                                </div>
                                            )}
                                        </div>
                                    ) : (
                                        <div className="word-list">
                                        {Object.entries(getFilteredWords()).map(([hiragana, data]) => {
                                            const isFavorite = getCurrentSetFavorites()[hiragana];
                                            return (
                                                <div key={hiragana} className="word-item slide-in" style={{
                                                    border: isFavorite ? '2px solid #f39c12' : '1px solid #e1e8ed',
                                                    backgroundColor: isFavorite ? 'rgba(241, 196, 15, 0.05)' : 'transparent'
                                                }}>
                                                    <div>
                                                        <strong style={{ color: isFavorite ? '#f39c12' : 'inherit' }}>
                                                            {isFavorite ? 'â­ ' : ''}{hiragana}
                                                        </strong>
                                                        {data.kanji && <span> ({data.kanji})</span>}
                                                        <span> - {data.korean}</span>
                                                    </div>
                                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                        <button 
                                                            className="btn"
                                                            style={{ 
                                                                padding: '0.5rem 1rem', 
                                                                fontSize: '0.9rem',
                                                                background: isFavorite ? 'linear-gradient(45deg, #f39c12, #e67e22)' : 'linear-gradient(45deg, #bdc3c7, #95a5a6)',
                                                                color: 'white'
                                                            }}
                                                            onClick={() => toggleWordFavorite(hiragana)}
                                                            title={isFavorite ? "ì¦ê²¨ì°¾ê¸° í•´ì œ" : "ì¦ê²¨ì°¾ê¸° ì¶”ê°€"}
                                                        >
                                                            {isFavorite ? 'â­ í‘œì‹œë¨' : 'â˜† í‘œì‹œ'}
                                                        </button>
                                                        <button 
                                                            className="btn btn-primary"
                                                            style={{ 
                                                                padding: '0.5rem 1rem', 
                                                                fontSize: '0.9rem',
                                                                background: 'linear-gradient(45deg, #3498db, #2980b9)'
                                                            }}
                                                            onClick={() => startEditWord(hiragana)}
                                                            title="ë‹¨ì–´ ìˆ˜ì •í•˜ê¸°"
                                                        >
                                                            âœï¸ ìˆ˜ì •
                                                        </button>
                                                        <button 
                                                            className="btn btn-danger"
                                                            style={{ padding: '0.5rem 1rem', fontSize: '0.9rem' }}
                                                            onClick={async () => await deleteWord(hiragana)}
                                                            title="í´ë¦­í•˜ë©´ í™•ì¸ íŒì—…ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤"
                                                        >
                                                            ğŸ—‘ï¸ ì‚­ì œ
                                                        </button>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        </div>
                                    )}
                                </div>
                            )}

                            {currentTab === 'add' && (
                                <div className="card fade-in">
                                    <h2 style={{ marginBottom: '2rem', color: '#2c3e50' }}>
                                        {isEditMode ? `ğŸ“ ë‹¨ì–´ ìˆ˜ì •: ${editingWordKey}` : 'â• ìƒˆ ë‹¨ì–´ ì¶”ê°€'}
                                    </h2>
                                    
                                    {isEditMode && (
                                        <div style={{
                                            background: 'rgba(241, 196, 15, 0.1)',
                                            border: '2px solid rgba(241, 196, 15, 0.3)',
                                            borderRadius: '12px',
                                            padding: '1rem',
                                            marginBottom: '2rem'
                                        }}>
                                            <div style={{ color: '#f39c12', fontWeight: 'bold', marginBottom: '0.5rem' }}>
                                                ğŸ”„ ìˆ˜ì • ëª¨ë“œ í™œì„±í™”
                                            </div>
                                            <div style={{ color: '#2c3e50', fontSize: '0.9rem', marginBottom: '1rem' }}>
                                                '{editingWordKey}' ë‹¨ì–´ë¥¼ ìˆ˜ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤. ëª¨ë“  í•„ë“œë¥¼ ììœ ë¡­ê²Œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                                            </div>
                                            <button 
                                                className="btn btn-secondary"
                                                onClick={cancelEdit}
                                                style={{ 
                                                    padding: '0.5rem 1rem', 
                                                    fontSize: '0.9rem',
                                                    background: '#95a5a6'
                                                }}
                                            >
                                                âŒ ìˆ˜ì • ì·¨ì†Œ
                                            </button>
                                        </div>
                                    )}
                                    
                                    <div className="hangul-converter">
                                        <div className="input-group">
                                            <label className="input-label">í•œê¸€ ë°œìŒ (ìë™ë³€í™˜):</label>
                                            <input
                                                type="text"
                                                className="input-field"
                                                value={hangulInput}
                                                onChange={(e) => setHangulInput(e.target.value)}
                                                placeholder="ì˜ˆ: ê°“ì½”ìš°, ì„¼ì„¸ì´, ê°¸ì¿ "
                                            />
                                            <div style={{ fontSize: '0.9rem', color: '#666', marginTop: '0.5rem' }}>
                                                ğŸ’¡ ë³µì¡í•œ ë°œìŒë„ ì§€ì›: "ê°“" (ã¤), "ìƒ¤" (ã—ã‚ƒ), "í" (ãã‚…) ë“±
                                            </div>
                                        </div>
                                        {convertedHiragana && (
                                            <div style={{ marginTop: '1rem', padding: '1rem', backgroundColor: 'rgba(52, 152, 219, 0.1)', borderRadius: '8px' }}>
                                                <div style={{ color: '#3498db', fontWeight: 'bold', fontSize: '1.2rem' }}>
                                                    ğŸŒ ë³€í™˜ ê²°ê³¼: {convertedHiragana}
                                                </div>
                                                <button 
                                                    className="btn btn-primary" 
                                                    style={{ marginTop: '0.5rem', padding: '0.5rem 1rem', fontSize: '0.9rem' }}
                                                    onClick={useConvertedWord}
                                                >
                                                    âœ¨ íˆë¼ê°€ë‚˜ ë€ì— ì ìš©
                                                </button>
                                            </div>
                                        )}
                                    </div>

                                    <div className="input-group">
                                        <label className="input-label">íˆë¼ê°€ë‚˜/ê°€íƒ€ì¹´ë‚˜:</label>
                                        <input
                                            type="text"
                                            className="input-field"
                                            value={newHiragana}
                                            onChange={(e) => setNewHiragana(e.target.value)}
                                            placeholder="ì˜ˆ: ãŒã£ã“ã† (ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ APIì—ì„œ í•œì ê²€ìƒ‰)"
                                        />
                                    </div>

                                    <div className="input-group">
                                        <label className="input-label">í•œì (ğŸŒ API ìë™ê²€ìƒ‰):</label>
                                        <input
                                            type="text"
                                            className="input-field"
                                            value={newKanji}
                                            onChange={(e) => setNewKanji(e.target.value)}
                                            placeholder="ì˜ˆ: å­¦æ ¡"
                                        />
                                        {kanjiStatus && (
                                            <div className={`status-indicator ${kanjiStatus.includes('âœ…') || kanjiStatus.includes('ğŸ”') ? 'status-success' : 'status-error'}`}>
                                                {kanjiStatus}
                                            </div>
                                        )}
                                        
                                        {/* í•œì í›„ë³´ ëª©ë¡ */}
                                        {kanjiCandidates.length > 0 && (
                                            <div style={{ 
                                                marginTop: '1rem', 
                                                border: '2px solid #3498db', 
                                                borderRadius: '8px', 
                                                padding: '1rem',
                                                backgroundColor: 'rgba(52, 152, 219, 0.05)'
                                            }}>
                                                <div style={{ marginBottom: '0.5rem', fontWeight: 'bold', color: '#2c3e50' }}>
                                                    ğŸ¯ í•œì í›„ë³´ ëª©ë¡ (í´ë¦­í•´ì„œ ì„ íƒ):
                                                </div>
                                                <div style={{ display: 'grid', gap: '0.5rem' }}>
                                                    {kanjiCandidates.map((candidate, index) => (
                                                        <div 
                                                            key={index}
                                                            onClick={() => selectKanjiCandidate(candidate)}
                                                            style={{
                                                                padding: '0.8rem',
                                                                border: '1px solid #bdc3c7',
                                                                borderRadius: '6px',
                                                                cursor: 'pointer',
                                                                transition: 'all 0.2s ease',
                                                                backgroundColor: newKanji === candidate.kanji ? 'rgba(46, 204, 113, 0.1)' : 'white'
                                                            }}
                                                            onMouseEnter={(e) => e.target.style.backgroundColor = 'rgba(52, 152, 219, 0.1)'}
                                                            onMouseLeave={(e) => e.target.style.backgroundColor = newKanji === candidate.kanji ? 'rgba(46, 204, 113, 0.1)' : 'white'}
                                                        >
                                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                <div>
                                                                    <span style={{ fontSize: '1.4rem', fontWeight: 'bold', marginRight: '0.5rem' }}>
                                                                        {candidate.kanji}
                                                                    </span>
                                                                    <span style={{ color: '#7f8c8d', fontSize: '0.9rem' }}>
                                                                        ({candidate.reading})
                                                                    </span>
                                                                </div>
                                                                {candidate.meanings && (
                                                                    <div style={{ fontSize: '0.9rem', color: '#34495e', textAlign: 'right', maxWidth: '200px' }}>
                                                                        {candidate.meanings}
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        <div style={{ fontSize: '0.9rem', color: '#666', marginTop: '0.5rem' }}>
                                            ğŸŒ Jisho.org APIë¥¼ í†µí•´ ì‹¤ì‹œê°„ í•œì ê²€ìƒ‰
                                        </div>
                                    </div>

                                    <div className="input-group">
                                        <label className="input-label">í•œêµ­ì–´ ëœ»:</label>
                                        <input
                                            type="text"
                                            className="input-field"
                                            value={newKorean}
                                            onChange={(e) => setNewKorean(e.target.value)}
                                            placeholder="ì˜ˆ: í•™êµ"
                                        />
                                    </div>

                                    <div className="btn-group">
                                        <button className="btn btn-success" onClick={async () => await addNewWord()}>
                                            {isEditMode ? 'âœ… ìˆ˜ì • ì™„ë£Œ' : 'â• ë‹¨ì–´ ì¶”ê°€'}
                                        </button>
                                        
                                    </div>
                                </div>
                            )}

                            {currentTab === 'data' && (
                                <div className="card fade-in">
                                    <h2 style={{ marginBottom: '2rem', color: '#2c3e50' }}>ğŸ’¾ ë°ì´í„° ê´€ë¦¬</h2>
                                    
                                    {/* ì „ì²´ ë‹¨ì–´ì¥ ì„¤ì • ì„¹ì…˜ */}
                                    <div style={{ marginBottom: '3rem' }}>
                                        <h3 style={{ 
                                            color: '#34495e', 
                                            marginBottom: '1.5rem',
                                            borderBottom: '2px solid #e74c3c',
                                            paddingBottom: '0.5rem'
                                        }}>ğŸ”§ ì „ì²´ ë‹¨ì–´ì¥ ì„¤ì •</h3>
                                        
                                        <div style={{
                                            background: 'rgba(231, 76, 60, 0.1)',
                                            padding: '1.5rem',
                                            borderRadius: '12px',
                                            border: '1px solid rgba(231, 76, 60, 0.3)',
                                            marginBottom: '1rem'
                                        }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                                <h4 style={{ color: '#e74c3c', margin: 0 }}>ğŸ“‹ í¬í•¨í•  ë‹¨ì–´ì¥ ì„ íƒ</h4>
                                                <button 
                                                    className="btn btn-warning"
                                                    onClick={() => setShowSetSelector(!showSetSelector)}
                                                    style={{ fontSize: '0.9rem', padding: '0.5rem 1rem' }}
                                                >
                                                    {showSetSelector ? 'ğŸ“ ì„ íƒ ì™„ë£Œ' : 'âœï¸ ë‹¨ì–´ì¥ ì„ íƒ'}
                                                </button>
                                            </div>
                                            
                                            {showSetSelector ? (
                                                <div>
                                                    <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
                                                        ì „ì²´ ë‹¨ì–´ì¥ì— í¬í•¨í•  ë‹¨ì–´ì¥ë“¤ì„ ì„ íƒí•˜ì„¸ìš”. ì„ íƒí•˜ì§€ ì•Šìœ¼ë©´ ëª¨ë“  ë‹¨ì–´ì¥ì´ í¬í•¨ë©ë‹ˆë‹¤.
                                                    </p>
                                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '0.8rem' }}>
                                                        {Object.entries(setNames).filter(([setId]) => setId !== 'combined').map(([setId, setName]) => (
                                                            <label 
                                                                key={setId}
                                                                style={{ 
                                                                    display: 'flex', 
                                                                    alignItems: 'center', 
                                                                    gap: '0.5rem',
                                                                    padding: '0.7rem',
                                                                    background: selectedSetsForCombined[setId] ? 'rgba(231, 76, 60, 0.1)' : 'rgba(255, 255, 255, 0.5)',
                                                                    borderRadius: '8px',
                                                                    border: selectedSetsForCombined[setId] ? '2px solid #e74c3c' : '1px solid #ddd',
                                                                    cursor: 'pointer'
                                                                }}
                                                            >
                                                                <input 
                                                                    type="checkbox"
                                                                    checked={selectedSetsForCombined[setId] || false}
                                                                    onChange={(e) => {
                                                                        const newSelection = {
                                                                            ...selectedSetsForCombined,
                                                                            [setId]: e.target.checked
                                                                        };
                                                                        setSelectedSetsForCombined(newSelection);
                                                                        saveSelectedSets(newSelection);
                                                                        // ì¦‰ì‹œ ì „ì²´ ë‹¨ì–´ì¥ ì—…ë°ì´íŠ¸
                                                                        setTimeout(() => updateCombinedWordSet(), 100);
                                                                    }}
                                                                    style={{ marginRight: '0.3rem' }}
                                                                />
                                                                <span style={{ fontSize: '0.9rem', color: selectedSetsForCombined[setId] ? '#e74c3c' : '#333' }}>
                                                                    {setName} ({Object.keys(wordSets[setId] || {}).length}ê°œ)
                                                                </span>
                                                            </label>
                                                        ))}
                                                    </div>
                                                    <div style={{ marginTop: '1rem', padding: '0.8rem', background: 'rgba(52, 152, 219, 0.1)', borderRadius: '6px' }}>
                                                        <small style={{ color: '#2980b9' }}>
                                                            ğŸ’¡ í˜„ì¬ ì„ íƒ: {Object.values(selectedSetsForCombined).filter(Boolean).length}ê°œ ë‹¨ì–´ì¥ |
                                                            ì „ì²´ ë‹¨ì–´ì¥ì— í¬í•¨ë  ë‹¨ì–´: {(() => {
                                                                const hasSelection = Object.keys(selectedSetsForCombined).some(setId => selectedSetsForCombined[setId]);
                                                                if (!hasSelection) return Object.values(wordSets).filter((_, i) => Object.keys(wordSets)[i] !== 'combined').reduce((total, set) => total + Object.keys(set).length, 0);
                                                                return Object.entries(wordSets)
                                                                    .filter(([setId]) => setId !== 'combined' && selectedSetsForCombined[setId])
                                                                    .reduce((total, [_, set]) => total + Object.keys(set).length, 0);
                                                            })()}ê°œ
                                                        </small>
                                                    </div>
                                                </div>
                                            ) : (
                                                <p style={{ fontSize: '0.9rem', color: '#666', margin: 0 }}>
                                                    í˜„ì¬ ì „ì²´ ë‹¨ì–´ì¥ì€ {(() => {
                                                        const hasSelection = Object.keys(selectedSetsForCombined).some(setId => selectedSetsForCombined[setId]);
                                                        const selectedCount = Object.values(selectedSetsForCombined).filter(Boolean).length;
                                                        const totalSets = Object.keys(setNames).filter(setId => setId !== 'combined').length;
                                                        return hasSelection ? `ì„ íƒëœ ${selectedCount}ê°œ ë‹¨ì–´ì¥` : `ëª¨ë“  ${totalSets}ê°œ ë‹¨ì–´ì¥`;
                                                    })()}ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.
                                                </p>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸° ì„¹ì…˜ */}
                                    <div style={{ marginBottom: '3rem' }}>
                                        <h3 style={{ 
                                            color: '#34495e', 
                                            marginBottom: '1.5rem',
                                            borderBottom: '2px solid #3498db',
                                            paddingBottom: '0.5rem'
                                        }}>ğŸ“ íŒŒì¼ ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°</h3>
                                        
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
                                            {/* JSON ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸° */}
                                            <div style={{
                                                background: 'rgba(52, 152, 219, 0.1)',
                                                padding: '1.5rem',
                                                borderRadius: '12px',
                                                border: '1px solid rgba(52, 152, 219, 0.3)'
                                            }}>
                                                <h4 style={{ color: '#3498db', marginBottom: '1rem' }}>ğŸ—‚ï¸ JSON í˜•ì‹</h4>
                                                <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
                                                    ëª¨ë“  ë‹¨ì–´ì¥ ì„¸íŠ¸ì™€ ì„¤ì •ì„ ì™„ì „íˆ ë°±ì—…/ë³µì›í•©ë‹ˆë‹¤. ë‹¤ë¥¸ ê¸°ê¸°ë¡œ ì™„ì „íˆ ì´ì „í•  ë•Œ ê¶Œì¥í•©ë‹ˆë‹¤.
                                                </p>
                                                <div className="btn-group">
                                                    <button className="btn btn-primary" onClick={exportToJSON}>
                                                        ğŸ“¥ JSON ë‚´ë³´ë‚´ê¸°
                                                    </button>
                                                    <label className="btn btn-success" style={{ cursor: 'pointer' }}>
                                                        ğŸ“¤ JSON ê°€ì ¸ì˜¤ê¸°
                                                        <input
                                                            type="file"
                                                            accept=".json"
                                                            onChange={importFromJSON}
                                                            style={{ display: 'none' }}
                                                        />
                                                    </label>
                                                </div>
                                            </div>

                                            {/* CSV ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸° */}
                                            <div style={{
                                                background: 'rgba(46, 204, 113, 0.1)',
                                                padding: '1.5rem',
                                                borderRadius: '12px',
                                                border: '1px solid rgba(46, 204, 113, 0.3)'
                                            }}>
                                                <h4 style={{ color: '#2ecc71', marginBottom: '1rem' }}>ğŸ“Š CSV í˜•ì‹</h4>
                                                <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
                                                    ì—‘ì…€, êµ¬ê¸€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ ë“±ì—ì„œ í¸ì§‘ ê°€ëŠ¥í•œ í˜•ì‹ì…ë‹ˆë‹¤. ëŒ€ëŸ‰ í¸ì§‘ì´ í•„ìš”í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.
                                                </p>
                                                <div className="btn-group">
                                                    <button className="btn btn-success" onClick={exportToCSV}>
                                                        ğŸ“¥ CSV ë‚´ë³´ë‚´ê¸°
                                                    </button>
                                                    <label className="btn btn-warning" style={{ cursor: 'pointer' }}>
                                                        ğŸ“¤ CSV ê°€ì ¸ì˜¤ê¸°
                                                        <input
                                                            type="file"
                                                            accept=".csv"
                                                            onChange={importFromCSV}
                                                            style={{ display: 'none' }}
                                                        />
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* ë°±ì—…/ë³µì› ì„¹ì…˜ */}
                                    <div style={{ marginBottom: '3rem' }}>
                                        <h3 style={{ 
                                            color: '#34495e', 
                                            marginBottom: '1.5rem',
                                            borderBottom: '2px solid #e67e22',
                                            paddingBottom: '0.5rem'
                                        }}>ğŸ”„ ë°±ì—… ë° ë³µì›</h3>
                                        
                                        <div style={{
                                            background: 'rgba(230, 126, 34, 0.1)',
                                            padding: '1.5rem',
                                            borderRadius: '12px',
                                            border: '1px solid rgba(230, 126, 34, 0.3)',
                                            marginBottom: '1rem'
                                        }}>
                                            <h4 style={{ color: '#e67e22', marginBottom: '1rem' }}>âš¡ ìë™ ë°±ì—…</h4>
                                            <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
                                                ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜ ì‚­ì œí•  ë•Œ ìë™ìœ¼ë¡œ ë°±ì—…ì´ ìƒì„±ë©ë‹ˆë‹¤. ë°±ì—…ì€ ë¸Œë¼ìš°ì €ì— ì €ì¥ë˜ë©° ì–¸ì œë“ ì§€ ë³µì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                                            </p>
                                            <button className="btn btn-warning" onClick={restoreBackup}>
                                                ğŸ”™ ë§ˆì§€ë§‰ ë°±ì—… ë³µì›
                                            </button>
                                        </div>
                                    </div>

                                    {/* ë°ì´í„° ì •ë³´ ì„¹ì…˜ */}
                                    <div style={{ marginBottom: '3rem' }}>
                                        <h3 style={{ 
                                            color: '#34495e', 
                                            marginBottom: '1.5rem',
                                            borderBottom: '2px solid #9b59b6',
                                            paddingBottom: '0.5rem'
                                        }}>ğŸ“Š í˜„ì¬ ë°ì´í„° ì •ë³´</h3>
                                        
                                        <div style={{
                                            background: 'rgba(155, 89, 182, 0.1)',
                                            padding: '1.5rem',
                                            borderRadius: '12px',
                                            border: '1px solid rgba(155, 89, 182, 0.3)'
                                        }}>
                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
                                                <div>
                                                    <h4 style={{ color: '#9b59b6' }}>ğŸ“š ë‹¨ì–´ì¥ ì„¸íŠ¸</h4>
                                                    <p style={{ fontSize: '1.2rem', fontWeight: 'bold', color: '#2c3e50' }}>
                                                        {Object.keys(wordSets).length}ê°œ
                                                    </p>
                                                </div>
                                                <div>
                                                    <h4 style={{ color: '#9b59b6' }}>ğŸ“ ì´ ë‹¨ì–´ ìˆ˜</h4>
                                                    <p style={{ fontSize: '1.2rem', fontWeight: 'bold', color: '#2c3e50' }}>
                                                        {Object.values(wordSets).reduce((total, set) => total + Object.keys(set).length, 0)}ê°œ
                                                    </p>
                                                </div>
                                                <div>
                                                    <h4 style={{ color: '#9b59b6' }}>â­ í‘œì‹œëœ ë‹¨ì–´</h4>
                                                    <p style={{ fontSize: '1.2rem', fontWeight: 'bold', color: '#2c3e50' }}>
                                                        {Object.values(wordSets).reduce((total, set) => 
                                                            total + Object.values(set).filter(word => word.favorite).length, 0
                                                        )}ê°œ
                                                    </p>
                                                </div>
                                                <div>
                                                    <h4 style={{ color: '#9b59b6' }}>ğŸ“– í˜„ì¬ ì„¸íŠ¸</h4>
                                                    <p style={{ fontSize: '1.2rem', fontWeight: 'bold', color: '#2c3e50' }}>
                                                        {setNames[currentSetId]}
                                                    </p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* ìœ„í—˜í•œ ì‘ì—… ì„¹ì…˜ */}
                                    <div>
                                        <h3 style={{ 
                                            color: '#e74c3c', 
                                            marginBottom: '1.5rem',
                                            borderBottom: '2px solid #e74c3c',
                                            paddingBottom: '0.5rem'
                                        }}>âš ï¸ ìœ„í—˜í•œ ì‘ì—…</h3>
                                        
                                        <div style={{
                                            background: 'rgba(231, 76, 60, 0.1)',
                                            padding: '1.5rem',
                                            borderRadius: '12px',
                                            border: '1px solid rgba(231, 76, 60, 0.3)'
                                        }}>
                                            <h4 style={{ color: '#e74c3c', marginBottom: '1rem' }}>ğŸ—‘ï¸ ì „ì²´ ë°ì´í„° ì‚­ì œ</h4>
                                            <p style={{ fontSize: '0.9rem', color: '#666', marginBottom: '1rem' }}>
                                                ëª¨ë“  ë‹¨ì–´ì¥, ì„¸íŠ¸, ì„¤ì •ì„ ì™„ì „íˆ ì‚­ì œí•©ë‹ˆë‹¤. ì‚­ì œí•˜ê¸° ì „ì— ë°˜ë“œì‹œ ë°±ì—…ì„ ë§Œë“œì„¸ìš”!
                                            </p>
                                            <button 
                                                className="btn btn-danger" 
                                                onClick={clearAllData}
                                                style={{ 
                                                    background: '#e74c3c',
                                                    border: '2px solid #c0392b'
                                                }}
                                            >
                                                âš ï¸ ëª¨ë“  ë°ì´í„° ì‚­ì œ
                                            </button>
                                        </div>
                                    </div>

                                    {/* ë„ì›€ë§ ì„¹ì…˜ */}
                                    <div style={{ 
                                        marginTop: '3rem',
                                        background: 'rgba(52, 73, 94, 0.1)',
                                        padding: '1.5rem',
                                        borderRadius: '12px',
                                        border: '1px solid rgba(52, 73, 94, 0.3)'
                                    }}>
                                        <h4 style={{ color: '#34495e', marginBottom: '1rem' }}>ğŸ’¡ ì‚¬ìš© íŒ</h4>
                                        <ul style={{ color: '#666', paddingLeft: '1.5rem' }}>
                                            <li>ì •ê¸°ì ìœ¼ë¡œ JSON ë°±ì—…ì„ ë§Œë“¤ì–´ ë‹¤ë¥¸ ê³³ì— ì €ì¥í•˜ì„¸ìš”</li>
                                            <li>CSV í˜•ì‹ì€ Excelì—ì„œ ë‹¨ì–´ë¥¼ ëŒ€ëŸ‰ í¸ì§‘í•œ í›„ ë‹¤ì‹œ ê°€ì ¸ì˜¬ ë•Œ ìœ ìš©í•©ë‹ˆë‹¤</li>
                                            <li>ë¸Œë¼ìš°ì € ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê¸° ì „ì— ë°˜ë“œì‹œ ë°±ì—…ì„ ë§Œë“œì„¸ìš”</li>
                                            <li>ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œ ì‚¬ìš©í•˜ë ¤ë©´ JSON íŒŒì¼ì„ ë‚´ë³´ë‚¸ í›„ ìƒˆ ê¸°ê¸°ì—ì„œ ê°€ì ¸ì˜¤ì„¸ìš”</li>
                                        </ul>
                                    </div>
                                </div>
                            )}
                        </div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<JapaneseStudyApp />);
    </script>
    
    <!-- PWA ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡ -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('ServiceWorker ë“±ë¡ ì„±ê³µ: ', registration.scope);
                    }, function(err) {
                        console.log('ServiceWorker ë“±ë¡ ì‹¤íŒ¨: ', err);
                    });
            });
        }
        
        // PWA ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA ì„¤ì¹˜ ê°€ëŠ¥!');
            e.preventDefault();
            deferredPrompt = e;
            
            // ì„¤ì¹˜ ì•ˆë‚´ í‘œì‹œ (3ì´ˆ í›„)
            setTimeout(() => {
                if (confirm('ğŸ“± ì´ ì•±ì„ í™ˆ í™”ë©´ì— ì„¤ì¹˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì„¤ì¹˜í•˜ë©´ ë” ë¹ ë¥´ê³  í¸ë¦¬í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”!')) {
                    deferredPrompt.prompt();
                    deferredPrompt.userChoice.then((choiceResult) => {
                        if (choiceResult.outcome === 'accepted') {
                            console.log('ì‚¬ìš©ìê°€ PWA ì„¤ì¹˜ë¥¼ í—ˆìš©í–ˆìŠµë‹ˆë‹¤');
                        } else {
                            console.log('ì‚¬ìš©ìê°€ PWA ì„¤ì¹˜ë¥¼ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤');
                        }
                        deferredPrompt = null;
                    });
                }
            }, 3000);
        });
    </script>
</body>
</html>